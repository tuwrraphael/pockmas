{"version":3,"file":"5ce12894e6e96d21cfe3.bundle.js","mappings":"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","sources":["webpack://pockmas/webpack/runtime/chunk loaded","webpack://pockmas/webpack/runtime/startup chunk dependencies","webpack://pockmas/./src/utils/copyToWasmMemory.ts","webpack://pockmas/./src/lib/RouteInfoStore.ts","webpack://pockmas/./src/lib/RoutingService.ts","webpack://pockmas/./raptor/config.ts","webpack://pockmas/./src/lib/time/getDayOffset.ts","webpack://pockmas/./src/lib/time/addDays.ts","webpack://pockmas/./src/lib/RouteDetailsService.ts","webpack://pockmas/./src/lib/RouteUrlEncoder.ts","webpack://pockmas/./src/lib/RealtimeLookupService.ts","webpack://pockmas/./src/lib/StopGroupStore.ts","webpack://pockmas/./src/lib/time/TimezoneUtility.ts","webpack://pockmas/./src/state/worker.ts","webpack://pockmas/./src/lib/RoutingServicesFactory.ts","webpack://pockmas/webpack/bootstrap","webpack://pockmas/webpack/runtime/define property getters","webpack://pockmas/webpack/runtime/ensure chunk","webpack://pockmas/webpack/runtime/get javascript chunk filename","webpack://pockmas/webpack/runtime/get mini-css chunk filename","webpack://pockmas/webpack/runtime/global","webpack://pockmas/webpack/runtime/hasOwnProperty shorthand","webpack://pockmas/webpack/runtime/make namespace object","webpack://pockmas/webpack/runtime/publicPath","webpack://pockmas/webpack/runtime/importScripts chunk loading","webpack://pockmas/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(610).then(next);\n};","export async function copyToWasmMemory<T extends WebAssembly.Exports & { memory: WebAssembly.Memory; }>(instance: WebAssemblyInstance<T>,\n    res: Response,\n    numSizes: number,\n    getOffset: (instance: WebAssemblyInstance<T>, sizes: number[]) => number) {\n    let reader = res.body.getReader();\n    let done = false;\n    let offset;\n    let sizes = [];\n    let sizesBuffer = new Uint8Array(numSizes * 4);\n    let received = 0;\n    while (!done) {\n        let read = await reader.read();\n        done = read.done;\n        if (read.done) {\n            break;\n        }\n        let data = read.value;\n\n        if (sizes.length == 0) {\n            sizesBuffer.set(data.slice(0, Math.min(4 * numSizes - received, data.byteLength)), received);\n            received += data.byteLength;\n            if (received < numSizes * 4) {\n                continue;\n            } else {\n                let view = new DataView(sizesBuffer.buffer);\n                for (let i = 0; i < numSizes; i++) {\n                    sizes.push(view.getUint32(i * 4, true));\n                }\n                data = data.slice(numSizes * 4 - received);\n            }\n        }\n        if (sizes.length > 0 && offset == undefined) {\n            offset = getOffset(instance, sizes);\n        }\n        if (offset != undefined) {\n            new Uint8Array(instance.exports.memory.buffer, offset, data.length).set(data);\n            offset += data.length;\n        }\n    }\n}\n","import { RealtimeIdentifier } from \"./RealtimeIdentifier\";\nimport { Route } from \"./Route\";\nimport { RouteClass } from \"./RouteClass\";\nimport { Stop } from \"./Stop\";\n\nexport class RouteInfoStore {\n    constructor(private routes: [routeClass: number, headsignVariant: number][],\n        private routeClasses: {\n            routeClassName: string;\n            headsignVariants: string[],\n            routeType: number;\n            routeColor?: string;\n        }[],\n        private routeClassesByRealtimeIdentifier: [realtimeIdentiferType: number, realtimeIdentifier: number, ...routeClasses: number[]][],\n        private stops: [name: string, realtimeIdentifierType?: number, realtimeIdentifier?: number][]) {\n\n    }\n\n    getRealtimeIdentifier(stopId: number): RealtimeIdentifier {\n        if (this.stops[stopId].length < 1) {\n            return null;\n        }\n        return {\n            type: this.stops[stopId][1],\n            value: this.stops[stopId][2]\n        };\n    }\n\n    getStop(stopId: number): Stop {\n        if (stopId > this.stops.length) {\n            throw new Error(`Invalid stop id ${stopId}`);\n        }\n        return {\n            stopId: stopId,\n            stopName: this.stops[stopId][0]\n        };\n    }\n\n    getRoute(routeId: number): Route {\n        if (routeId > this.routes.length) {\n            throw new Error(`Invalid route id ${routeId}`);\n        }\n        let route = this.routes[routeId];\n        let routeClass = this.routeClasses[route[0]];\n        let color = \"\";\n        if (routeClass.routeColor) {\n            color = routeClass.routeColor;\n        } else if (routeClass.routeType == 0) {\n            color = \"c4121a\";\n        }\n        return {\n            name: this.routeClasses[route[0]].routeClassName,\n            id: routeId,\n            color: color,\n            headsign: routeClass.headsignVariants[route[1]]\n        };\n    }\n\n    getRouteClassesFotRealtimeIdentifier(realtimeIdentifier: RealtimeIdentifier): RouteClass[] {\n        let realtimeIdentifierType = realtimeIdentifier.type;\n        let realtimeIdentifierValue = realtimeIdentifier.value;\n        let routeClasses = this.routeClassesByRealtimeIdentifier.find(r => r[0] == realtimeIdentifierType && r[1] == realtimeIdentifierValue).slice(2);\n        return routeClasses.map(id => ({\n            routeClassName: this.routeClasses[id].routeClassName,\n            headsignVariants: this.routeClasses[id].headsignVariants,\n            id: id\n        }));\n    }\n}\n","import { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { WienerLinienMonitorResponse } from \"../realtime-api/WienerLinienMonitorResponse\";\nimport { OebbMonitorResponse } from \"../realtime-api/OebbMonitorResponse\";\nimport { Departure } from \"./Departure\";\nimport { TimezoneUtility } from \"./time/TimezoneUtility\";\nimport { Itinerary } from \"./Itinerary\";\nimport { Leg } from \"./Leg\";\nimport { RealtimeData } from \"./RealtimeData\";\nimport { RealtimeIdentifier } from \"./RealtimeIdentifier\";\nimport { RealtimeIdentifierType } from \"./RealtimeIdentifierType\";\nimport { ResolvedRealtimeData } from \"./ResolvedRealtimeData\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { compareTwoStrings } from \"string-similarity\";\nimport { MAX_REQUEST_STATIONS } from \"../../raptor/config\";\n\nexport interface RouteRequest {\n    departureStops: number[];\n    arrivalStops: number[];\n    departureTimes: Date[];\n}\n\nconst RAPTOR_MAX_REQUEST_STATIONS = MAX_REQUEST_STATIONS;\n\nconst RAPTOR_LEG_SIZE = 24;\nconst RAPTOR_MAX_LEGS = 10;\nconst RAPTOR_ITINERARY_SIZE = RAPTOR_MAX_LEGS * RAPTOR_LEG_SIZE + 4;\nconst RAPTOR_MAX_ITINERARIES = 8;\nconst RAPTOR_RESULTS_SIZE = RAPTOR_MAX_ITINERARIES * RAPTOR_ITINERARY_SIZE + 4;\n\nconst RAPTOR_MAX_STOPTIME_UPDATES = 5;\nconst RAPTOR_UPDATE_RESULT_SIZE = 2 + 2 + 2 + 2;\n\nconst RAPTOR_STOPTIME_UPDATE_SIZE = 4 + // realtime_route_identifier\n    2 +  // linie\n    1 + // direction\n    1 + // weekday\n    4 + // date\n    1 + // apply\n    1 + // num_updates\n    2 + // realtime_route_identifier_type\n    RAPTOR_MAX_STOPTIME_UPDATES * 4 + // time_real\n    RAPTOR_MAX_STOPTIME_UPDATES * RAPTOR_UPDATE_RESULT_SIZE + // results\n    RAPTOR_MAX_STOPTIME_UPDATES * 1; // matches\n\nconst DEPARTURE_RESULT_SIZE = 2 + // route_id\n    2 + // stop_id\n    4 + // trip\n    4 + // planned_departure\n    2 + // delay\n    2; // padding\n\nconst MAX_DEPARTURE_RESULTS = 10;\nconst DEPARTURE_RESULTS_SIZE = MAX_DEPARTURE_RESULTS * DEPARTURE_RESULT_SIZE + 4;\n\nexport class RoutingService {\n    private mappedRealtimeData: { [routeId: number]: Set<number> } = {};\n\n    constructor(private routingInstance: WebAssemblyInstance<RaptorExports>,\n        private routeInfoStore: RouteInfoStore,\n        private timezoneUtility: TimezoneUtility) {\n\n    }\n\n    hasRealtime(routeId: number, trip: number) {\n        return this.mappedRealtimeData[routeId]?.has(trip) || false;\n    }\n\n    private mapToDeparture(view: DataView, offset: number) {\n        let route = this.routeInfoStore.getRoute(view.getUint16(offset, true));\n        let tripId = view.getUint32(offset + 4, true);\n        let departure: Departure = {\n            route: route,\n            stop: this.routeInfoStore.getStop(view.getUint16(offset + 2, true)),\n            tripId: tripId,\n            plannedDeparture: new Date(view.getUint32(offset + 8, true) * 1000),\n            delay: view.getInt16(offset + 12, true),\n            isRealtime: this.hasRealtime(route.id, tripId)\n        };\n        return departure;\n    }\n\n    getDepartures(r: { departureStops: { stopId: number, departureTime: Date }[] }): Departure[] {\n        this.setRequest({ ...r, arrivalStops: [] });\n        let offset = this.routingInstance.exports.get_departures();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, offset, DEPARTURE_RESULTS_SIZE);\n        let numResults = view.getUint32(0, true);\n        let departures: Departure[] = [];\n        for (let i = 0; i < numResults; i++) {\n            let departure = this.mapToDeparture(view, 4 + i * DEPARTURE_RESULT_SIZE);\n            departures.push(departure);\n        }\n        return departures;\n    }\n\n    private setRequest(r: { departureStops: { stopId: number, departureTime: Date }[], arrivalStops: number[] }) {\n        let requestMemory = this.routingInstance.exports.get_request_memory();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, requestMemory, 4 + 4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4);\n        view.setUint8(0, 0);\n        view.setUint8(1, Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length));\n        view.setUint8(2, Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.arrivalStops.length));\n        let startOfDayVienna = this.timezoneUtility.getStartOfDay(r.departureStops[0].departureTime);\n        view.setUint8(3, startOfDayVienna.dayOfWeek);\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            view.setUint16(4 + i * 2, r.departureStops[i].stopId, true);\n        }\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.arrivalStops.length); i++) {\n            view.setUint16(4 + RAPTOR_MAX_REQUEST_STATIONS * 2 + i * 2, r.arrivalStops[i], true);\n        }\n        let departureDate = startOfDayVienna.unixTime / 1000;\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            let departureTime = (+r.departureStops[i].departureTime - startOfDayVienna.unixTime) / 1000;\n            view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + i * 4, departureTime, true);\n        }\n        view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4, departureDate, true);\n    }\n\n    route(request: RouteRequest) {\n        if (request.departureStops.length != request.departureTimes.length) {\n            throw new Error(\"departureStops and departureTimes must have the same length\");\n        }\n        performance.mark(\"routing-start\");\n        this.setRequest({ departureStops: request.departureStops.map((d, i) => ({ stopId: d, departureTime: request.departureTimes[i] })), arrivalStops: request.arrivalStops });\n        let resOffset = this.routingInstance.exports.raptor();\n        performance.mark(\"routing-done\");\n        performance.measure(\"routing\", \"routing-start\", \"routing-done\");\n        console.log(`routing took ${(performance.getEntriesByName(\"routing\")[0]).duration}ms`);\n        performance.clearMarks();\n        performance.clearMeasures();\n        let results = this.readResults(this.routingInstance.exports.memory, resOffset);\n        return results;\n    }\n\n    private async getRealtimeForWienerLinien(divas: number[]): Promise<RealtimeData[]> {\n        let params = new URLSearchParams();\n        for (let diva of divas) {\n            params.append(\"diva\", diva.toString());\n        }\n        let res = await fetch(`https://realtime-api.grapp.workers.dev/ogd_realtime/monitor?${params}`);\n        let monitorResponse: WienerLinienMonitorResponse = await res.json();\n        let result: RealtimeData[] = [];\n        for (let monitor of monitorResponse.data.monitors) {\n            let identifier: RealtimeIdentifier = {\n                type: RealtimeIdentifierType.WienerLinien,\n                value: parseInt(monitor.locationStop.properties.name)\n            };\n            for (let line of monitor.lines) {\n                let byLineAndHeadsign: Map<string, Map<string, Date[]>> = new Map();\n                for (let departure of line.departures.departure) {\n                    if (departure.departureTime?.timeReal || departure.departureTime?.timePlanned) {\n                        let byHeadsign: Map<string, Date[]> = byLineAndHeadsign.get(departure.vehicle?.name || line.name) || new Map();\n                        let departureTime = departure.departureTime.timeReal ? new Date(departure.departureTime.timeReal) : new Date(departure.departureTime.timePlanned);\n                        let departureTimes = byHeadsign.get(departure.vehicle?.towards || line.towards) || [];\n                        departureTimes.push(departureTime);\n                        byHeadsign.set(departure.vehicle?.towards || line.towards, departureTimes);\n                        byLineAndHeadsign.set(departure.vehicle?.name || line.name, byHeadsign);\n                    } else {\n                        console.log(`no departure time in departure`, departure);\n                    }\n                }\n                for (let [routeClassName, byHeadsign] of byLineAndHeadsign) {\n                    for (let [headsign, departureTimes] of byHeadsign) {\n                        let realtimeData: RealtimeData = {\n                            realtimeIdentifier: identifier,\n                            routeClassName: routeClassName,\n                            headsign: headsign,\n                            times: departureTimes\n                        };\n\n                        result.push(realtimeData);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private parseOebbDate(date: string, time: string): Date | null {\n        const dateRegex = /^(\\d{2})\\.(\\d{2})\\.(\\d{4})$/;\n        const timeRegex = /^(\\d{2}):(\\d{2})$/;\n        if (!date || !time || !dateRegex.test(date) || !timeRegex.test(time)) {\n            console.log(`unexpected oebb date or time: \"${date}\" \"${time}\"`);\n            return null;\n        }\n        let dateParts = date.split(\".\");\n        let timeParts = time.split(\":\");\n        return this.timezoneUtility.getDateInTimezone(+dateParts[2], +dateParts[1], +dateParts[0], +timeParts[0], +timeParts[1], 0);\n    }\n\n    private async *getRealtimeForOebb(evaIds: number[]): AsyncGenerator<RealtimeData> {\n        for (let evaId of evaIds) {\n            let res = await fetch(`https://realtime-api.grapp.workers.dev/bin/stboard.exe/dn?L=vs_scotty.vs_liveticker&evaId=${evaId}&boardType=dep&productsFilter=1011111111011&additionalTime=0&disableEquivs=yes&maxJourneys=20&outputMode=tickerDataOnly&start=yes&selectDate=today`);\n            let data: OebbMonitorResponse = await res.json();\n            let identifier: RealtimeIdentifier = {\n                type: RealtimeIdentifierType.OEBB,\n                value: evaId\n            };\n            let byLineAndHeadsign: Map<string, Map<string, Date[]>> = new Map();\n            for (let journey of data.journey) {\n                if (!journey.pr) {\n                    console.log(`no journey.pr in journey`, journey);\n                    continue;\n                }\n                if (!journey.st) {\n                    console.log(`no journey.st in journey`, journey);\n                    continue;\n                }\n                if (journey.rt && journey.rt.status == \"Ausfall\") {\n                    console.log(`Ausfall not supported yet`, journey);\n                    continue;\n                }\n                let realtime: Date = null;\n                if (journey.rt) {\n                    realtime = this.parseOebbDate(journey.rt.dld, journey.rt.dlt);\n                } else {\n                    realtime = this.parseOebbDate(journey.da, journey.ti);\n                }\n                if (null != realtime) {\n                    let byHeadsign: Map<string, Date[]> = byLineAndHeadsign.get(journey.pr) || new Map();\n                    let departureTimes = byHeadsign.get(journey.st) || [];\n                    departureTimes.push(realtime);\n                    byHeadsign.set(journey.st, departureTimes);\n                    byLineAndHeadsign.set(journey.pr, byHeadsign);\n                } else {\n                    console.log(`no departure time in journey`, journey);\n                }\n            }\n            for (let [routeClassName, byHeadsign] of byLineAndHeadsign) {\n                for (let [headsign, departureTimes] of byHeadsign) {\n                    let realtimeData: RealtimeData = {\n                        realtimeIdentifier: identifier,\n                        routeClassName: routeClassName,\n                        headsign: headsign,\n                        times: departureTimes\n                    };\n                    yield realtimeData;\n                }\n            }\n        }\n    }\n\n    async updateRealtimeForStops(realtimeIdentifiers: RealtimeIdentifier[]) {\n        let data = await this.getRealtimeForWienerLinien(realtimeIdentifiers.filter(v => v.type == RealtimeIdentifierType.WienerLinien).map(i => i.value));\n        for (let realtimeData of data) {\n            this.upsertRealtimeData(realtimeData, true);\n        }\n        for await (let realtimeData of this.getRealtimeForOebb(realtimeIdentifiers.filter(v => v.type == RealtimeIdentifierType.OEBB).map(i => i.value))) {\n            this.upsertRealtimeData(realtimeData, true);\n        }\n    }\n\n    private readLeg(buffer: ArrayBuffer, offset: number): Leg {\n        let view = new DataView(buffer, offset, RAPTOR_LEG_SIZE);\n        let departureStopId = view.getUint16(4, true);\n        let arrivalStopId = view.getUint16(6, true);\n        let departureSeconds = view.getUint32(8, true);\n        let arrivalSeconds = view.getUint32(12, true);\n        let leg: Leg = {\n            type: view.getUint32(0, true),\n            departureStop: this.routeInfoStore.getStop(departureStopId),\n            arrivalStop: this.routeInfoStore.getStop(arrivalStopId),\n            plannedDeparture: new Date(departureSeconds * 1000),\n            delay: view.getInt16(18, true),\n            arrivalTime: new Date(arrivalSeconds * 1000),\n            duration: (arrivalSeconds - departureSeconds) * 1000,\n            route: null,\n            tripId: null,\n            isRealtime: false\n        };\n        if (leg.type == 1) {\n            let routeId = view.getUint16(16, true);\n            leg.route = this.routeInfoStore.getRoute(routeId);\n            leg.tripId = view.getUint32(20, true);\n            leg.isRealtime = this.hasRealtime(leg.route.id, leg.tripId);\n        }\n        return leg;\n    }\n\n    private readItinerary(buffer: ArrayBuffer, offset: number): Itinerary {\n        let legs = [];\n        let view = new DataView(buffer, offset, RAPTOR_ITINERARY_SIZE);\n        let numLegs = view.getUint32(0, true);\n        for (let i = 0; i < numLegs; i++) {\n            legs.push(this.readLeg(buffer, offset + 4 + i * RAPTOR_LEG_SIZE));\n        }\n        return { legs: legs.reverse() };\n    }\n\n    private readResults(memory: WebAssembly.Memory, offset: number): Itinerary[] {\n        let itineraries = [];\n        let view = new DataView(memory.buffer, offset, RAPTOR_RESULTS_SIZE);\n        let numItineraries = view.getUint32(0, true);\n        for (let i = 0; i < numItineraries; i++) {\n            let itinerary = this.readItinerary(memory.buffer, offset + 4 + i * RAPTOR_ITINERARY_SIZE);\n            itineraries.push(itinerary);\n        }\n        return itineraries;\n    }\n\n\n    private readStoptimeUpdate(buffer: ArrayBuffer, offset: number) {\n        let view = new DataView(buffer, offset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let routeId = view.getUint16(0, true);\n        let trip = view.getUint16(2, true);\n        let realtimeOffset = view.getInt16(4, true);\n        return {\n            routeId: routeId,\n            route: this.routeInfoStore.getRoute(routeId).name,\n            trip: trip,\n            realtimeOffset: realtimeOffset\n        };\n    }\n\n    getRealtimeUpdateResult() {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let numUpdates = dataView.getUint8(13);\n        let updates = [];\n        for (let i = 0; i < numUpdates; i++) {\n            let update = this.readStoptimeUpdate(this.routingInstance.exports.memory.buffer, memoryOffset + 16 + (4 * RAPTOR_MAX_STOPTIME_UPDATES) + (i * RAPTOR_UPDATE_RESULT_SIZE));\n            updates.push({ ...update, numMatches: dataView.getUint8(16 + RAPTOR_MAX_STOPTIME_UPDATES * (RAPTOR_UPDATE_RESULT_SIZE + 4) + i) });\n        }\n        return updates;\n    }\n\n    upsertRealtimeData(realtimeData: RealtimeData, apply: boolean) {\n        // performance.mark(\"realtime-upsert-start\");\n        let routeClasses = this.routeInfoStore.getRouteClassesFotRealtimeIdentifier(realtimeData.realtimeIdentifier);\n        let routeShortNameCleaned = realtimeData.routeClassName.replace(/\\s/g, \"\").toLowerCase();\n        let routeClassesCleaned = routeClasses.map(c => c.routeClassName.replace(/\\s/g, \"\").toLowerCase());\n        let matchingRouteClass = routeClasses[routeClassesCleaned.findIndex(c => c == routeShortNameCleaned)];\n        if (!matchingRouteClass) {\n            console.log(`no matching route class for ${realtimeData.routeClassName}`);\n            return;\n        }\n        let headsignCleaned = realtimeData.headsign.replace(/^Wien /, \"\").trim().toLowerCase();\n        let headsignVariantsCleaned = matchingRouteClass.headsignVariants.map(h => h.replace(/^Wien /, \"\").toLowerCase());\n        let similarities : number[] = headsignVariantsCleaned.map(h => compareTwoStrings(headsignCleaned, h));\n        // let bestHeadsignVariantMatch = findBestMatch(headsignCleaned, headsignVariantsCleaned);\n        let sortedIndices = similarities.map((v, i) => ({variantIndex:i, similarity:v})).sort((a, b) => b.similarity - a.similarity);\n        for (let candidate of sortedIndices){\n            this.upsertResolvedRealtimeData({\n                headsignVariant: candidate.variantIndex,\n                realtimeIdentifier: realtimeData.realtimeIdentifier,\n                routeClass: matchingRouteClass.id,\n                times: realtimeData.times\n            }, false);\n            let res = this.getRealtimeUpdateResult();\n            if (res.some(r => r.numMatches > 0)) {\n                this.upsertResolvedRealtimeData({\n                    headsignVariant: candidate.variantIndex,\n                    realtimeIdentifier: realtimeData.realtimeIdentifier,\n                    routeClass: matchingRouteClass.id,\n                    times: realtimeData.times\n                }, apply);\n                return;\n            }\n        }\n        // performance.mark(\"realtime-upsert-end\");\n        // performance.measure(\"realtime-upsert\", \"realtime-upsert-start\", \"realtime-upsert-end\");\n        // console.log(`Realtime upsert took ${performance.getEntriesByName(\"realtime-upsert\", \"measure\")[0].duration}ms`);\n        // performance.clearMarks();\n        // performance.clearMeasures();\n    }\n\n    private upsertResolvedRealtimeData(update: ResolvedRealtimeData, apply: boolean) {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        dataView.setUint32(0, update.realtimeIdentifier.value, true);\n        dataView.setUint16(4, update.routeClass, true);\n        dataView.setUint8(6, update.headsignVariant);\n        let date = this.timezoneUtility.getStartOfDay(update.times[0]);\n        dataView.setUint8(7, date.dayOfWeek);\n        dataView.setUint32(8, date.unixTime / 1000, true);\n        dataView.setUint8(12, apply ? 1 : 0);\n        let numUpdates = Math.min(update.times.length, RAPTOR_MAX_STOPTIME_UPDATES);\n        dataView.setUint8(13, numUpdates);\n        dataView.setUint16(14, update.realtimeIdentifier.type, true);\n        for (let i = 0; i < numUpdates; i++) {\n            dataView.setUint32(16 + i * 4, (+update.times[i] - date.unixTime) / 1000, true);\n        }\n        this.routingInstance.exports.process_realtime();\n        let res = this.getRealtimeUpdateResult();\n        for (let update of res) {\n            if (update.numMatches > 0) {\n                this.mappedRealtimeData[update.routeId] = this.mappedRealtimeData[update.routeId] || new Set();\n                this.mappedRealtimeData[update.routeId].add(update.trip);\n            }\n        }\n    }\n}","// must match raptor.h\nexport const MAX_REQUEST_STATIONS = 35;","export function getDayOffset(reference: { unixTime: number; }, date: Date) {\n    return Math.floor((date.getTime() - reference.unixTime) / 86400000);\n}\n","\nexport function addDays(date: Date, days: number) {\n    return new Date(date.getTime() + days * 86400000);\n}\n","import { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { Itinerary } from \"./Itinerary\";\nimport { Leg } from \"./Leg\";\nimport { LegType } from \"./LegType\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { DecodedItinerary, RouteUrlEncoder } from \"./RouteUrlEncoder\";\nimport { RoutingService } from \"./RoutingService\";\nimport { TimezoneUtility } from \"./time/TimezoneUtility\";\nimport { getDayOffset } from \"./time/getDayOffset\";\nimport { addDays } from \"./time/addDays\";\n\nconst STOPTIME_LOOKUP_RESULT_SIZE = 4 + //planned_departure\n    4 + // planned_arrival\n    2; // delay\n\nexport class RouteDetailsService {\n    constructor(private routeUrlEncoder: RouteUrlEncoder,\n        private routeInfoStore: RouteInfoStore,\n        private routingInstance: WebAssemblyInstance<RaptorExports>,\n        private routingService: RoutingService,\n        private timezoneUtility: TimezoneUtility) {\n    }\n\n    private getStoptime(routeId: number, stopId: number, trip: number) {\n        let offset = this.routingInstance.exports.get_stoptime(routeId, stopId, trip);\n        let view = new DataView(this.routingInstance.exports.memory.buffer, offset, STOPTIME_LOOKUP_RESULT_SIZE);\n        return {\n            departureTime: view.getUint32(0, true),\n            arrivalTime: view.getUint32(4, true),\n            delay: view.getInt16(8, true)\n        };\n    }\n\n    private reconstructTimes(stopTime: { departureStopDepartureTime: number, arrvialStopArrivalTime: number },\n        itineraryDepartureStartOfDay: { unixTime: number }, expectedDayOffset: number) {\n        let departureTime = new Date(itineraryDepartureStartOfDay.unixTime + stopTime.departureStopDepartureTime * 1000);\n        let dayOffset = getDayOffset(itineraryDepartureStartOfDay, departureTime);\n        return {\n            plannedDeparture: addDays(departureTime, expectedDayOffset - dayOffset),\n            plannedArrival: addDays(new Date(itineraryDepartureStartOfDay.unixTime + stopTime.arrvialStopArrivalTime * 1000), expectedDayOffset - dayOffset)\n        };\n    }\n\n    private reconstructLeg(l: DecodedItinerary[\"legs\"][0], itineraryDepartureStartOfDay: { unixTime: number }, legDepartureTime: Date) {\n        switch (l.type) {\n            case LegType.Transit: {\n                let departureStoptime = this.getStoptime(l.routeId, l.departureStopId, l.tripId);\n                let arrivalStoptime = this.getStoptime(l.routeId, l.arrivalStopId, l.tripId);\n                let times = this.reconstructTimes({\n                    departureStopDepartureTime: departureStoptime.departureTime,\n                    arrvialStopArrivalTime: arrivalStoptime.arrivalTime\n                }, itineraryDepartureStartOfDay, l.dayOffset);\n                return {\n                    type: LegType.Transit,\n                    departureStop: this.routeInfoStore.getStop(l.departureStopId),\n                    arrivalStop: this.routeInfoStore.getStop(l.arrivalStopId),\n                    route: this.routeInfoStore.getRoute(l.routeId),\n                    arrivalTime: new Date(+times.plannedArrival + arrivalStoptime.delay * 1000),\n                    plannedDeparture: times.plannedDeparture,\n                    delay: departureStoptime.delay,\n                    duration: +times.plannedArrival - +times.plannedDeparture,\n                    isRealtime: this.routingService.hasRealtime(l.routeId, l.tripId),\n                    tripId: l.tripId\n                };\n            }\n            case LegType.Walking: {\n                let duration = this.routingInstance.exports.get_transfer_time(l.departureStopId, l.arrivalStopId);\n                return {\n                    type: LegType.Walking,\n                    departureStop: this.routeInfoStore.getStop(l.departureStopId),\n                    arrivalStop: this.routeInfoStore.getStop(l.arrivalStopId),\n                    route: null,\n                    tripId: null,\n                    plannedDeparture: legDepartureTime,\n                    arrivalTime: new Date(+legDepartureTime + (duration * 1000)),\n                    delay: 0,\n                    duration: duration * 1000,\n                    isRealtime: false\n                };\n            }\n        }\n    }\n\n    getRouteByUrl(itineraryUrl: string): Itinerary {\n        let decoded = this.routeUrlEncoder.decode(itineraryUrl);\n        let legs: Leg[] = [];\n        let legDepartureTime = decoded.departureTime;\n        let itineraryDepartureStartOfDay = this.timezoneUtility.getStartOfDay(decoded.departureTime);\n        for (let l of decoded.legs) {\n            let leg = this.reconstructLeg(l, itineraryDepartureStartOfDay, legDepartureTime);\n            legs.push(leg);\n            legDepartureTime = leg.arrivalTime;\n        }\n        return {\n            legs: legs\n        }\n    }\n}","import { LegType } from \"./LegType\";\nimport { Base64 } from \"js-base64\";\nimport { Stop } from \"./Stop\";\nimport { TimezoneUtility } from \"./time/TimezoneUtility\";\nimport { getDayOffset } from \"./time/getDayOffset\";\n\nconst UrlVersion = 2;\n\nexport interface DecodedItinerary {\n    departureTime: Date;\n    version: number;\n    legs: {\n        dayOffset: number;\n        type: LegType;\n        departureStopId: number;\n        arrivalStopId: number;\n        routeId: number;\n        tripId: number;\n    }[];\n\n}\n\nclass DataVersionMismatchError extends Error {\n    constructor(public expected: string, public actual: string) {\n        super(`Data version mismatch - expected ${expected}, actual ${actual}`);\n    }\n}\n\nexport class RouteUrlEncoder {\n    public readonly UrlVersion = UrlVersion;\n\n    constructor(private dataVersion: string, private timezoneUtility: TimezoneUtility) {\n\n    }\n\n    private getEncodedString(binary: Uint8Array): string {\n        return `${UrlVersion}${Base64.fromUint8Array(binary, true)}!${this.dataVersion}`\n    }\n\n    encode(r: {\n        legs: {\n            type: LegType;\n            departureStop: Stop;\n            arrivalStop: Stop;\n            route: {\n                id: number;\n            };\n            tripId: number | null;\n            plannedDeparture: Date;\n        }[]\n    }): string {\n        let binary = new Uint8Array(1 + 4 + r.legs.filter(v => v.type == LegType.Transit).length * 10 +\n            r.legs.filter(v => v.type == LegType.Walking).length * 5);\n        let view = new DataView(binary.buffer);\n        view.setUint8(0, r.legs.length);\n        if (r.legs.length < 1) {\n            return this.getEncodedString(binary);\n        }\n        view.setUint32(1, r.legs.length > 0 ? (r.legs[0].plannedDeparture.getTime() / 1000) : 0, true);\n        let itineraryDepartureStartOfDay = this.timezoneUtility.getStartOfDay(r.legs[0].plannedDeparture);\n        let offset = 5;\n        for (let l of r.legs) {\n            view.setUint8(offset + 0, l.type);\n            view.setUint16(offset + 1, l.departureStop.stopId, true);\n            view.setUint16(offset + 3, l.arrivalStop.stopId, true);\n            offset += 5;\n            if (l.type === LegType.Transit) {\n                view.setUint16(offset, l.route?.id || 0, true);\n                view.setUint16(offset + 2, l.tripId || 0, true);\n                view.setUint8(offset + 4, getDayOffset(itineraryDepartureStartOfDay, l.plannedDeparture));\n                offset += 5;\n            }\n        }\n        return this.getEncodedString(binary);\n    }\n\n    decode(url: string): DecodedItinerary {\n        let version = parseInt(url.substr(0, 1));\n        switch (version) {\n            case 1:\n                return this.decodeV1(url);\n            case 2:\n                return this.decodeV2(url);\n            default:\n                break;\n        }\n        throw new Error(`Unsupported version ${version}`);\n    }\n\n    private decodeV2(url: string): DecodedItinerary {\n        let [data, dataVersion] = url.substr(1).split(\"!\");\n        if (dataVersion !== this.dataVersion) {\n            throw new DataVersionMismatchError(this.dataVersion, dataVersion);\n        }\n        let binary = Base64.toUint8Array(data);\n        let view = new DataView(binary.buffer);\n        let numLegs = view.getUint8(0);\n        let departureTime = new Date(view.getUint32(1, true) * 1000);\n        let legs: {\n            type: LegType;\n            departureStopId: number;\n            arrivalStopId: number;\n            routeId: number;\n            tripId: number;\n            dayOffset: number;\n        }[] = [];\n        let offset = 5;\n        for (let i = 0; i < numLegs; i++) {\n            let type = view.getUint8(offset + 0);\n            let departureStopId = view.getUint16(offset + 1, true);\n            let arrivalStopId = view.getUint16(offset + 3, true);\n            offset += 5;\n            if (type === LegType.Transit) {\n                let routeId = view.getUint16(offset, true);\n                let tripId = view.getUint16(offset + 2, true);\n                let dayOffset = view.getUint8(offset + 4);\n                offset += 5;\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId,\n                    tripId,\n                    dayOffset: dayOffset\n                });\n            } else {\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId: null,\n                    tripId: null,\n                    dayOffset: 0\n                });\n            }\n        }\n        return {\n            departureTime,\n            version: 1,\n            legs\n        };\n    }\n\n    private decodeV1(url: string): DecodedItinerary {\n        let [data, dataVersion] = url.substr(1).split(\"!\");\n        if (dataVersion !== this.dataVersion) {\n            throw new DataVersionMismatchError(this.dataVersion, dataVersion);\n        }\n        let binary = Base64.toUint8Array(data);\n        let view = new DataView(binary.buffer);\n        let numLegs = view.getUint8(0);\n        let departureTime = new Date(view.getUint32(1, true) * 1000);\n        let legs: {\n            type: LegType;\n            departureStopId: number;\n            arrivalStopId: number;\n            routeId: number;\n            tripId: number;\n            dayOffset: number;\n        }[] = [];\n        let offset = 5;\n        for (let i = 0; i < numLegs; i++) {\n            let type = view.getUint8(offset + 0);\n            let departureStopId = view.getUint16(offset + 1, true);\n            let arrivalStopId = view.getUint16(offset + 3, true);\n            offset += 5;\n            if (type === LegType.Transit) {\n                let routeId = view.getUint16(offset, true);\n                let tripId = view.getUint16(offset + 2, true);\n                offset += 4;\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId,\n                    tripId,\n                    dayOffset: 0\n                });\n            } else {\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId: null,\n                    tripId: null,\n                    dayOffset: 0\n                });\n            }\n        }\n        return {\n            departureTime,\n            version: 1,\n            legs\n        };\n    }\n\n\n}","import { RoutingService } from \"./RoutingService\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RealtimeIdentifier } from \"./RealtimeIdentifier\";\n\nexport class RealtimeLookupService {\n    private lookedUp: { rtIdentifier: RealtimeIdentifier, when: Date }[] = [];\n\n    constructor(private routeInfoStore: RouteInfoStore,\n        private routingService: RoutingService) {\n    }\n\n    private hasJustBeenLookedUp(rtIdentifier: RealtimeIdentifier) {\n        return this.lookedUp.some(lookedUp =>\n            lookedUp.rtIdentifier.type == rtIdentifier.type &&\n            lookedUp.rtIdentifier.value == rtIdentifier.value &&\n            (new Date().getTime() - lookedUp.when.getTime()) < 1000 * 30);\n    }\n\n    private setLookedUp(rtIdentifier: RealtimeIdentifier) {\n        let existing = this.lookedUp.find(lookedUp => lookedUp.rtIdentifier.type == rtIdentifier.type && lookedUp.rtIdentifier.value == rtIdentifier.value);\n        if (existing) {\n            existing.when = new Date();\n        }\n        else {\n            this.lookedUp.push({ rtIdentifier: rtIdentifier, when: new Date() });\n        }\n    }\n\n    async performWithRealtimeLoopkup(perform: () => Promise<number[]>) {\n        for (let i = 0; i < 10; i++) {\n            let stopIds = await perform();\n\n            let lookupIdentifiers: RealtimeIdentifier[] = [];\n            for (let id of stopIds.reduce((realtimeIdentifiers, stopId) => [...realtimeIdentifiers, this.routeInfoStore.getRealtimeIdentifier(stopId)], [])) {\n                if (id !== null && !this.hasJustBeenLookedUp(id) && !lookupIdentifiers.some(identifier => identifier.type == id.type && identifier.value == id.value)) {\n                    lookupIdentifiers.push(id);\n                }\n            }\n            if (lookupIdentifiers.length == 0) {\n                break;\n            }\n            await this.routingService.updateRealtimeForStops(lookupIdentifiers);\n            for (let id of lookupIdentifiers) {\n                this.setLookedUp(id);\n            }\n        }\n    }\n}\n","\nexport class StopGroupStore {\n    constructor(private sstopGroupIndex: { name: string; stopIds: number[]; }[]) {\n    }\n\n    getStopGroup(stopGroupId: number): { name: string; stopIds: number[]; } {\n        if (stopGroupId > this.sstopGroupIndex.length) {\n            throw new Error(`Invalid stop group id ${stopGroupId}`);\n        }\n        return this.sstopGroupIndex[stopGroupId];\n    }\n\n    findByStopId(stopId: number): { id: number; name: string; } {\n        let found = this.sstopGroupIndex.find(s => s.stopIds.includes(stopId));\n        if (null == found) {\n            return null;\n        }\n        return { id: found.stopIds.indexOf(stopId), name: found.name };\n    }\n}\n","import { findTimeZone, getUnixTime, getZonedTime } from \"timezone-support/lookup-convert\";\n\nexport class TimezoneUtility {\n\n    private timezone: any;\n\n    constructor(private tz: string) {\n    }\n\n    private getTimezone() {\n        if (!this.timezone) {\n            this.timezone = findTimeZone(this.tz);\n        }\n        return this.timezone;\n    }\n\n    private dayOfWeekToMask(dayOfWeek: number): number {\n        let mask = 0;\n        if (dayOfWeek == 0) {\n            mask = 64;\n        } else {\n            mask = 1 << (dayOfWeek - 1);\n        }\n        return mask;\n    }\n\n    getStartOfDay(date: Date) {\n        const viennaTime = getZonedTime(date, this.getTimezone());\n        const startOfDayVienna = getUnixTime({\n            year: viennaTime.year,\n            month: viennaTime.month,\n            day: viennaTime.day,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n        }, this.getTimezone());\n        return { unixTime: startOfDayVienna, dayOfWeek: this.dayOfWeekToMask(viennaTime.dayOfWeek) };\n    }\n\n    getDateInTimezone(year: number, month: number, day: number, hours: number, minutes: number, seconds: number) {\n        return new Date(getUnixTime({\n            year: year,\n            month: month,\n            day: day,\n            hours: hours,\n            minutes: minutes,\n            seconds: seconds,\n        }, this.getTimezone()));\n    }\n\n}\n","import { StopSearchExports } from \"../../stopsearch/wasm-exports\";\nimport { ActionType } from \"./actions/ActionType\";\nimport { ArrivalStopTermChanged } from \"./actions/ArrivalStopTermChanged\";\nimport { DepartureStopTermChanged } from \"./actions/DepartureStopTermChanged\";\nimport { InitializeRouting } from \"./actions/InitializeRouting\";\nimport { InitializeStopSearch } from \"./actions/InitializeStopSearch\";\nimport { State } from \"./State\";\nimport { StopsSelected } from \"./actions/StopsSelected\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { SetDepartureTime } from \"./actions/SetDepartureTime\";\nimport { RoutingServicesFactory } from \"../lib/RoutingServicesFactory\";\nimport { RouteDetailsOpened } from \"./actions/RouteDetailsOpened\";\nimport { DisplayMoreDepartures } from \"./actions/DisplayMoreDepartures\";\nimport { RefreshRouteDetails } from \"./actions/RefreshRouteDetails\";\nimport { LegType } from \"../lib/LegType\";\n\ntype Actions = InitializeStopSearch\n    | DepartureStopTermChanged\n    | ArrivalStopTermChanged\n    | InitializeRouting\n    | StopsSelected\n    | SetDepartureTime\n    | RouteDetailsOpened\n    | DisplayMoreDepartures\n    | RefreshRouteDetails;\n\nlet stopSearchInstance: WebAssemblyInstance<StopSearchExports>;\nlet _departureTime: Date = null;\n\nconst routingServicesFactory = new RoutingServicesFactory();\n\nasync function initRouting() {\n    await routingServicesFactory.getRoutingService();\n}\n\nasync function initStopSearch() {\n    if (stopSearchInstance) {\n        return;\n    }\n    let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<StopSearchExports>>>WebAssembly.instantiateStreaming(\n        fetch(new URL(\"../../stopsearch/stopsearch.wasm\", import.meta.url).toString())\n    ), fetch(new URL(\"../../preprocessing-dist/stop_search.bin.bmp\", import.meta.url).toString())]);\n    await Promise.all([await routingServicesFactory.getStopGroupStore(), copyToWasmMemory(instantiatedSource.instance, binaryResponse, 4, (instance, sizes) => instance.exports.stopsearch_allocate(sizes[0] / 12, sizes[1], sizes[3] / 2))]);\n    instantiatedSource.instance.exports.stopsearch_reset();\n    stopSearchInstance = instantiatedSource.instance;\n}\n\nlet lastValue: string = \"\";\nlet state: State = {\n    arrivalStopResults: [],\n    departureStopResults: [],\n    results: [],\n    routeDetail: null,\n    departures: [],\n    selectedStopgroups: {\n        departure: null,\n        arrival: null\n    }\n};\n\nfunction updateState(updateFn: (oldState: State) => Partial<State>) {\n    let update = updateFn(state);\n    state = {\n        ...state,\n        ...update\n    };\n    self.postMessage([update, Object.keys(update)]);\n}\n\nasync function searchTermChanged(term: string, departure: boolean) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    if (null == stopSearchInstance) {\n        return;\n    }\n    let value = term.toLowerCase()\n        .replace(/ä/g, \"a\")\n        .replace(/ö/g, \"o\")\n        .replace(/ü/g, \"u\")\n        .replace(/ß/g, \"ss\")\n        .replace(/[^a-z0-9]/g, \" \")\n        .replace(/ +(?= )/g, '')\n        .trim()\n    if (value == lastValue) {\n        return;\n    }\n    let result;\n    if (value.length == lastValue.length + 1 && value.startsWith(lastValue)) {\n        result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(value.length - 1));\n    } else {\n        result = stopSearchInstance.exports.stopsearch_reset();\n        for (let i = 0; i < value.length; i++) {\n            result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(i));\n        }\n    }\n    lastValue = value;\n    let resultArrayView = new DataView(stopSearchInstance.exports.memory.buffer, result, 2 * 4);\n    let resultsCount = resultArrayView.getUint32(0, true);\n    let resultsOffset = resultArrayView.getUint32(4, true);\n    let resultsView = new DataView(stopSearchInstance.exports.memory.buffer, resultsOffset, resultsCount * 2);\n    let results: { id: number, name: string }[] = [];\n    for (let i = 0; i < resultsCount; i++) {\n        let stopGroupId = resultsView.getUint16(i * 2, true);\n        let stopGroup = stopGroupStore.getStopGroup(stopGroupId);\n        results.push({ id: stopGroupId, name: stopGroup.name });\n    }\n    updateState(s => ({\n        [departure ? \"departureStopResults\" : \"arrivalStopResults\"]: results\n    }));\n}\n\nlet getDeparturesRunning: Promise<void> = Promise.resolve();\n\nasync function searchInputChanged() {\n\n    if (state.selectedStopgroups.arrival != null && state.selectedStopgroups.departure != null) {\n        await route();\n    } else if (state.selectedStopgroups.departure != null) {\n        getDeparturesRunning = (async () => {\n            updateState(s => ({\n                results: []\n            }));\n            let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n            let routingService = await routingServicesFactory.getRoutingService();\n            let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n\n            let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n\n            await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n                let results = routingService.getDepartures({\n                    departureStops: departureStops.map(d => ({ departureTime: _departureTime, stopId: d })),\n                });\n                updateState(() => ({ departures: results }));\n                return results.map(r => r.stop.stopId);\n            });\n        })();\n        await getDeparturesRunning;\n    }\n}\n\nasync function displayMoreDepartures() {\n    await getDeparturesRunning;\n    if (state.selectedStopgroups.departure != null && state.departures?.length > 0) {\n        getDeparturesRunning = (async () => {\n            let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n            let routingService = await routingServicesFactory.getRoutingService();\n            let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n\n            let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n            let departuresBefore = state.departures;\n            await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n                let results = routingService.getDepartures({\n                    departureStops: departureStops.map(d => ({ departureTime: new Date(departuresBefore[departuresBefore.length - 1].plannedDeparture.getTime() + departuresBefore[departuresBefore.length - 1].delay), stopId: d })),\n                });\n                let firstDuplicate = departuresBefore.findIndex(dbefore => results.some(dNew => dbefore.route.id == dNew.route.id && dbefore.tripId == dNew.tripId && dbefore.stop.stopId == dNew.stop.stopId));\n                if (firstDuplicate != -1) {\n                    firstDuplicate = departuresBefore.length;\n                }\n                updateState(() => ({ departures: [...departuresBefore.slice(0, firstDuplicate), ...results] }));\n                return results.map(r => r.stop.stopId);\n            });\n        })();\n    }\n}\n\nasync function stopsSelected(d: number, a: number) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    updateState(s => ({\n        selectedStopgroups: {\n            departure: d == null ? null : { id: d, name: stopGroupStore.getStopGroup(d).name },\n            arrival: a == null ? null : { id: a, name: stopGroupStore.getStopGroup(a).name }\n        }\n    }));\n    _departureTime = new Date();\n    await searchInputChanged();\n}\n\nasync function departureTimeInc(inc: number) {\n    if (null == _departureTime) {\n        return;\n    }\n    _departureTime = new Date(_departureTime.getTime() + inc);\n    await searchInputChanged();\n}\n\nasync function route() {\n    let routingService = await routingServicesFactory.getRoutingService();\n    let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n\n    let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n    let arrivalStops = stopGroupStore.getStopGroup(state.selectedStopgroups.arrival.id).stopIds;\n\n    let routeUrlEncoder = await routingServicesFactory.getRouteUrlEncoder();\n\n    await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n        let results = routingService.route({\n            arrivalStops: arrivalStops,\n            departureStops: departureStops,\n            departureTimes: departureStops.map(() => _departureTime)\n        });\n        updateState(() => ({ results: results.map(i => ({ itineraryUrlEncoded: routeUrlEncoder.encode(i), itinerary: i })) }));\n        return results.reduce((stopIds, r) => [...stopIds, ...r.legs.map(l => l.departureStop.stopId)], []);\n    });\n}\n\nasync function refreshRouteDetails(itineraryIdUrlEncoded: string | null) {\n    itineraryIdUrlEncoded = itineraryIdUrlEncoded || state.routeDetail?.itineraryUrlEncoded;\n    if (!itineraryIdUrlEncoded) {\n        return;\n    }\n    let routeDetailsService = await routingServicesFactory.getRouteDetailsService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n\n    let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n    realtimeLookupService.performWithRealtimeLoopkup(async () => {\n        let itinerary = routeDetailsService.getRouteByUrl(itineraryIdUrlEncoded);\n        updateState(() => ({\n            routeDetail: { itineraryUrlEncoded: itineraryIdUrlEncoded, itinerary: itinerary },\n            selectedStopgroups: {\n                departure: stopGroupStore.findByStopId(itinerary.legs[0].departureStop.stopId),\n                arrival: stopGroupStore.findByStopId(itinerary.legs[itinerary.legs.length - 1].arrivalStop.stopId)\n            }\n        }));\n        return itinerary.legs.filter(l => l.type == LegType.Transit).reduce((stopIds, r) => [...stopIds, r.departureStop.stopId, r.arrivalStop.stopId], []);\n    });\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.InitializeStopSearch:\n            await initStopSearch();\n            break;\n        case ActionType.DepartureStopTermChanged: {\n            searchTermChanged(msg.term, true);\n            break;\n        }\n        case ActionType.ArrivalStopTermChanged: {\n            searchTermChanged(msg.term, false);\n            break;\n        }\n        case ActionType.InitializeRouting: {\n            await initRouting();\n            break;\n        }\n        case ActionType.StopsSelected: {\n            await stopsSelected(msg.departure, msg.arrival);\n            break;\n        }\n        case ActionType.SetDepartureTime: {\n            await departureTimeInc(msg.increment);\n            break;\n        }\n        case ActionType.RouteDetailsOpened: {\n            await refreshRouteDetails(msg.itineraryUrlEncoded);\n            break;\n        }\n        case ActionType.DisplayMoreDepartures: {\n            await displayMoreDepartures();\n            break;\n        }\n        case ActionType.RefreshRouteDetails: {\n            await refreshRouteDetails(null);\n            break;\n        }\n    }\n}\nself.postMessage([state, Object.keys(state)]);\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});","import { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RoutingService } from \"./RoutingService\";\nimport { populateTimeZones } from \"timezone-support/lookup-convert\";\nimport { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { RouteDetailsService } from \"./RouteDetailsService\";\nimport { RouteUrlEncoder } from \"./RouteUrlEncoder\";\nimport { RealtimeLookupService } from \"./RealtimeLookupService\";\nimport { StopGroupStore } from \"./StopGroupStore\";\nimport { TimezoneUtility } from \"./time/TimezoneUtility\";\n\nexport class RoutingServicesFactory {\n    private routingServicePromise: Promise<RoutingService>;\n    private routeInfoStorePromise: Promise<RouteInfoStore>;\n    private timezoneUtilityPromise: Promise<TimezoneUtility>;\n    private routingInstancePromise: Promise<WebAssemblyInstance<RaptorExports>>;\n    private routeDetailsServicePromise: Promise<RouteDetailsService>;\n    private readonly dataVersion = new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString().split(\"/\").pop().replace(\".bmp\", \"\");\n    private realtimeLookupServicePromise: Promise<RealtimeLookupService>;\n    private stopGroupStorePromise: Promise<StopGroupStore>;\n    private routeUrlEncoderPromise: Promise<RouteUrlEncoder>;\n\n    private async createTimezoneUtility() {\n        const { default: defaultFunc } = await import(\"timezone-support/data-1970-2038\");\n        populateTimeZones(defaultFunc);\n        return new TimezoneUtility(\"Europe/Vienna\");\n    }\n\n    private async getTimezoneUtility() {\n        if (this.timezoneUtilityPromise == null) {\n            this.timezoneUtilityPromise = this.createTimezoneUtility();\n        }\n        return this.timezoneUtilityPromise;\n    }\n\n    private async createRouteInfoStore() {\n        let routesTask = fetch(new URL(\"../../preprocessing-dist/routes.json\", import.meta.url).toString()).then(res => (res.json()) as Promise<[number, number][]>);\n        let stopsTask = fetch(new URL(\"../../preprocessing-dist/stops.json\", import.meta.url).toString()).then(res => res.json() as Promise<[string, number, number][]>);\n        let routeClassesTask = fetch(new URL(\"../../preprocessing-dist/route-classes.json\", import.meta.url).toString()).then(res => res.json() as Promise<{\n            routeClassName: string;\n            headsignVariants: string[];\n            routeType: number;\n            routeColor?: string;\n        }[]>);\n        let routeClassesByRealtimeIdentifierTask = fetch(new URL(\"../../preprocessing-dist/route-classes-by-realtime-identifier.json\", import.meta.url).toString()).then(res => res.json() as Promise<[type: number, value: number, ...routeClasses: number[]][]>);\n        let [routes, stops, routeClasses, routeClassesByRealtimeIdentifier] = await Promise.all([routesTask, stopsTask, routeClassesTask, routeClassesByRealtimeIdentifierTask]);\n        return new RouteInfoStore(routes, routeClasses, routeClassesByRealtimeIdentifier, stops);\n    }\n\n    private async createRoutingInstance() {\n        let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<RaptorExports>>>WebAssembly.instantiateStreaming(\n            fetch(new URL(\"../../raptor/raptor.wasm\", import.meta.url).toString())\n        ), fetch(new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString())]);\n        await copyToWasmMemory(instantiatedSource.instance, binaryResponse, 11,\n            (instance, sizes) => instance.exports.raptor_allocate(sizes[0], sizes[1], sizes[2], sizes[3], sizes[4], sizes[5], sizes[6], sizes[7], sizes[8], sizes[9], sizes[10]));\n        instantiatedSource.instance.exports.initialize();\n        return instantiatedSource.instance;\n    }\n\n    private async getRoutingInstance() {\n        if (this.routingInstancePromise == null) {\n            this.routingInstancePromise = this.createRoutingInstance();\n        }\n        return this.routingInstancePromise;\n    }\n\n    async getRouteInfoStore() {\n        if (this.routeInfoStorePromise == null) {\n            this.routeInfoStorePromise = this.createRouteInfoStore();\n        }\n        return this.routeInfoStorePromise;\n    }\n\n    private async createRoutingService() {\n        let [routingInstance, routeInfoStore, timezoneUtility] = await Promise.all([this.getRoutingInstance(), this.getRouteInfoStore(), this.getTimezoneUtility()])\n        return new RoutingService(routingInstance, routeInfoStore, timezoneUtility);\n    }\n\n    async getRoutingService() {\n        if (this.routingServicePromise == null) {\n            this.routingServicePromise = this.createRoutingService();\n        }\n        return this.routingServicePromise;\n    }\n\n    private async createRouteDetailsService() {\n        let [routingInstance, routeInfoStore, timezoneUtility, routingService] = await Promise.all([this.getRoutingInstance(), this.getRouteInfoStore(), this.getTimezoneUtility(), this.getRoutingService()])\n        return new RouteDetailsService(new RouteUrlEncoder(this.dataVersion, timezoneUtility), routeInfoStore, routingInstance, routingService, timezoneUtility);\n    }\n\n    async getRouteDetailsService() {\n        if (this.routeDetailsServicePromise == null) {\n            this.routeDetailsServicePromise = this.createRouteDetailsService();\n        }\n        return this.routeDetailsServicePromise;\n    }\n\n    private async createRealtimeLookupService() {\n        let [routingService, routeInfoStore] = await Promise.all([this.getRoutingService(), this.getRouteInfoStore()])\n        return new RealtimeLookupService(routeInfoStore, routingService);\n    }\n\n    async getRealtimeLookupService() {\n        if (this.realtimeLookupServicePromise == null) {\n            this.realtimeLookupServicePromise = this.createRealtimeLookupService();\n        }\n        return this.realtimeLookupServicePromise;\n    }\n\n    private async createStopGroupStore() {\n        let stopGroupIndexTask = fetch(new URL(\"../../preprocessing-dist/stopgroup-index.json\", import.meta.url).toString()).then(res => res.json()) as Promise<{ name: string; stopIds: number[] }[]>;\n        return new StopGroupStore(await stopGroupIndexTask);\n    }\n\n    async getStopGroupStore() {\n        if (this.stopGroupStorePromise == null) {\n            this.stopGroupStorePromise = this.createStopGroupStore();\n        }\n        return this.stopGroupStorePromise;\n    }\n\n    private async createRouteUrlEncoder() {\n        let timezoneUtility = await this.getTimezoneUtility();\n        return new RouteUrlEncoder(this.dataVersion, timezoneUtility);\n    }\n\n    async getRouteUrlEncoder() {\n        if (this.routeUrlEncoderPromise == null) {\n            this.routeUrlEncoderPromise = this.createRouteUrlEncoder();\n        }\n        return this.routeUrlEncoderPromise;\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [610], function() { return __webpack_require__(912); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + {\"340\":\"349baa5ee18c799559a0\",\"610\":\"96e99bd992fa95096738\"}[chunkId] + \".bundle.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t912: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpockmas\"] = self[\"webpackChunkpockmas\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","async","copyToWasmMemory","instance","res","numSizes","getOffset","offset","reader","body","getReader","done","sizes","sizesBuffer","Uint8Array","received","read","data","value","length","set","slice","Math","min","byteLength","view","DataView","buffer","i","push","getUint32","undefined","exports","memory","RouteInfoStore","constructor","routes","routeClasses","routeClassesByRealtimeIdentifier","stops","getRealtimeIdentifier","stopId","this","type","getStop","Error","stopName","getRoute","routeId","route","routeClass","color","routeColor","routeType","name","routeClassName","id","headsign","headsignVariants","getRouteClassesFotRealtimeIdentifier","realtimeIdentifier","realtimeIdentifierType","realtimeIdentifierValue","find","r","map","RoutingService","routingInstance","routeInfoStore","timezoneUtility","mappedRealtimeData","hasRealtime","trip","has","mapToDeparture","getUint16","tripId","stop","plannedDeparture","Date","delay","getInt16","isRealtime","getDepartures","setRequest","arrivalStops","get_departures","MAX_DEPARTURE_RESULTS","numResults","departures","departure","requestMemory","get_request_memory","setUint8","departureStops","startOfDayVienna","getStartOfDay","departureTime","dayOfWeek","setUint16","departureDate","unixTime","setUint32","request","departureTimes","performance","mark","d","resOffset","raptor","measure","console","log","getEntriesByName","duration","clearMarks","clearMeasures","readResults","divas","params","URLSearchParams","diva","append","toString","fetch","monitorResponse","json","result","monitor","monitors","identifier","parseInt","locationStop","properties","line","lines","byLineAndHeadsign","Map","timeReal","timePlanned","byHeadsign","get","vehicle","towards","realtimeData","times","parseOebbDate","date","time","test","dateParts","split","timeParts","getDateInTimezone","getRealtimeForOebb","evaIds","evaId","journey","pr","st","rt","status","realtime","dld","dlt","da","ti","realtimeIdentifiers","getRealtimeForWienerLinien","filter","v","upsertRealtimeData","_c","_d","readLeg","departureStopId","arrivalStopId","departureSeconds","arrivalSeconds","leg","departureStop","arrivalStop","arrivalTime","readItinerary","legs","numLegs","RAPTOR_MAX_LEGS","reverse","itineraries","numItineraries","RAPTOR_MAX_ITINERARIES","itinerary","readStoptimeUpdate","realtimeOffset","getRealtimeUpdateResult","memoryOffset","get_stoptime_update_memory","dataView","numUpdates","getUint8","updates","update","numMatches","apply","routeShortNameCleaned","replace","toLowerCase","routeClassesCleaned","c","matchingRouteClass","findIndex","headsignCleaned","trim","sortedIndices","h","compareTwoStrings","variantIndex","similarity","sort","a","b","candidate","upsertResolvedRealtimeData","headsignVariant","some","process_realtime","Set","add","getDayOffset","reference","floor","getTime","addDays","days","RouteDetailsService","routeUrlEncoder","routingService","getStoptime","get_stoptime","reconstructTimes","stopTime","itineraryDepartureStartOfDay","expectedDayOffset","departureStopDepartureTime","dayOffset","plannedArrival","arrvialStopArrivalTime","reconstructLeg","l","legDepartureTime","departureStoptime","arrivalStoptime","get_transfer_time","getRouteByUrl","itineraryUrl","decoded","decode","DataVersionMismatchError","expected","actual","super","RouteUrlEncoder","dataVersion","UrlVersion","getEncodedString","binary","Base64","encode","url","version","substr","decodeV1","decodeV2","RealtimeLookupService","lookedUp","hasJustBeenLookedUp","rtIdentifier","when","setLookedUp","existing","perform","stopIds","lookupIdentifiers","reduce","updateRealtimeForStops","StopGroupStore","sstopGroupIndex","getStopGroup","stopGroupId","findByStopId","found","s","includes","indexOf","TimezoneUtility","tz","getTimezone","timezone","findTimeZone","dayOfWeekToMask","mask","viennaTime","getZonedTime","getUnixTime","year","month","day","hours","minutes","seconds","stopSearchInstance","_departureTime","routingServicesFactory","URL","pop","default","defaultFunc","populateTimeZones","timezoneUtilityPromise","createTimezoneUtility","routesTask","then","stopsTask","routeClassesTask","routeClassesByRealtimeIdentifierTask","Promise","all","instantiatedSource","binaryResponse","WebAssembly","instantiateStreaming","raptor_allocate","initialize","routingInstancePromise","createRoutingInstance","routeInfoStorePromise","createRouteInfoStore","getRoutingInstance","getRouteInfoStore","getTimezoneUtility","routingServicePromise","createRoutingService","getRoutingService","routeDetailsServicePromise","createRouteDetailsService","realtimeLookupServicePromise","createRealtimeLookupService","stopGroupIndexTask","stopGroupStorePromise","createStopGroupStore","routeUrlEncoderPromise","createRouteUrlEncoder","lastValue","state","arrivalStopResults","departureStopResults","results","routeDetail","selectedStopgroups","arrival","updateState","updateFn","self","postMessage","Object","keys","searchTermChanged","term","stopGroupStore","getStopGroupStore","startsWith","stopsearch_step","charCodeAt","stopsearch_reset","resultArrayView","resultsCount","resultsOffset","resultsView","stopGroup","getDeparturesRunning","resolve","searchInputChanged","realtimeLookupService","getRealtimeLookupService","getRouteUrlEncoder","performWithRealtimeLoopkup","itineraryUrlEncoded","refreshRouteDetails","itineraryIdUrlEncoded","routeDetailsService","getRouteDetailsService","addEventListener","ev","msg","stopsearch_allocate","initStopSearch","initRouting","stopsSelected","inc","departureTimeInc","increment","departuresBefore","firstDuplicate","dbefore","dNew","displayMoreDepartures","handleMessage","catch","err","error","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","definition","o","defineProperty","enumerable","f","e","chunkId","promises","u","miniCssF","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime"],"sourceRoot":""}