{"version":3,"file":"813c858da9ba90ab529d.bundle.js","mappings":"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","sources":["webpack://pockmas/webpack/runtime/chunk loaded","webpack://pockmas/webpack/runtime/create fake namespace object","webpack://pockmas/webpack/runtime/startup chunk dependencies","webpack://pockmas/./src/utils/copyToWasmMemory.ts","webpack://pockmas/./src/lib/RouteUrlEncoder.ts","webpack://pockmas/./src/lib/RouteInfoStore.ts","webpack://pockmas/./src/lib/getStartOfDayVienna.ts","webpack://pockmas/./src/lib/RoutingService.ts","webpack://pockmas/./src/lib/RouteDetailsService.ts","webpack://pockmas/./src/lib/RealtimeLookupService.ts","webpack://pockmas/./src/lib/StopGroupStore.ts","webpack://pockmas/./src/state/worker.ts","webpack://pockmas/./src/lib/RoutingServicesFactory.ts","webpack://pockmas/webpack/bootstrap","webpack://pockmas/webpack/runtime/define property getters","webpack://pockmas/webpack/runtime/ensure chunk","webpack://pockmas/webpack/runtime/get javascript chunk filename","webpack://pockmas/webpack/runtime/get mini-css chunk filename","webpack://pockmas/webpack/runtime/global","webpack://pockmas/webpack/runtime/hasOwnProperty shorthand","webpack://pockmas/webpack/runtime/make namespace object","webpack://pockmas/webpack/runtime/publicPath","webpack://pockmas/webpack/runtime/importScripts chunk loading","webpack://pockmas/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(818),\n\t\t__webpack_require__.e(541)\n\t]).then(next);\n};","export async function copyToWasmMemory<T extends WebAssembly.Exports & { memory: WebAssembly.Memory; }>(instance: WebAssemblyInstance<T>,\n    res: Response,\n    numSizes: number,\n    getOffset: (instance: WebAssemblyInstance<T>, sizes: number[]) => number) {\n    let reader = res.body.getReader();\n    let done = false;\n    let offset;\n    let sizes = [];\n    let sizesBuffer = new Uint8Array(numSizes * 4);\n    let received = 0;\n    while (!done) {\n        let read = await reader.read();\n        done = read.done;\n        if (read.done) {\n            break;\n        }\n        let data = read.value;\n\n        if (sizes.length == 0) {\n            sizesBuffer.set(data.slice(0, Math.min(4 * numSizes - received, data.byteLength)), received);\n            received += data.byteLength;\n            if (received < numSizes * 4) {\n                continue;\n            } else {\n                let view = new DataView(sizesBuffer.buffer);\n                for (let i = 0; i < numSizes; i++) {\n                    sizes.push(view.getUint32(i * 4, true));\n                }\n                data = data.slice(numSizes * 4 - received);\n            }\n        }\n        if (sizes.length > 0 && offset == undefined) {\n            offset = getOffset(instance, sizes);\n        }\n        if (offset != undefined) {\n            new Uint8Array(instance.exports.memory.buffer, offset, data.length).set(data);\n            offset += data.length;\n        }\n    }\n}\n","import { LegType } from \"./LegType\";\nimport { Base64 } from \"js-base64\";\nimport { Stop } from \"./Stop\";\n\nconst UrlVersion = 1;\n\ninterface DecodedItinerary {\n    departureTime: Date;\n    version: number;\n    legs: {\n        type: LegType;\n        departureStopId: number;\n        arrivalStopId: number;\n        routeId: number;\n        tripId: number;\n    }[];\n\n}\n\nclass DataVersionMismatchError extends Error {\n    constructor(public expected: string, public actual: string) {\n        super(`Data version mismatch - expected ${expected}, actual ${actual}`);\n    }\n}\n\nexport class RouteUrlEncoder {\n    public readonly UrlVersion = UrlVersion;\n\n    constructor(private dataVersion: string) {\n\n    }\n\n    encode(r: {\n        legs: {\n            type: LegType;\n            departureStop: Stop;\n            arrivalStop: Stop;\n            route: {\n                id: number;\n            };\n            tripId: number | null;\n            plannedDeparture: Date;\n        }[]\n    }): string {\n        let binary = new Uint8Array(1 + 4 + r.legs.filter(v => v.type == LegType.Transit).length * 9 +\n            r.legs.filter(v => v.type == LegType.Walking).length * 5);\n        let view = new DataView(binary.buffer);\n        view.setUint8(0, r.legs.length);\n        view.setUint32(1, r.legs.length > 0 ? (r.legs[0].plannedDeparture.getTime() / 1000) : 0, true);\n        let offset = 5;\n        for (let l of r.legs) {\n            view.setUint8(offset + 0, l.type);\n            view.setUint16(offset + 1, l.departureStop.stopId, true);\n            view.setUint16(offset + 3, l.arrivalStop.stopId, true);\n            offset += 5;\n            if (l.type === LegType.Transit) {\n                view.setUint16(offset, l.route?.id || 0, true);\n                view.setUint16(offset + 2, l.tripId || 0, true);\n                offset += 4;\n            }\n        }\n        return `${UrlVersion}${Base64.fromUint8Array(binary, true)}!${this.dataVersion}`;\n    }\n\n    decode(url: string): DecodedItinerary {\n        let version = parseInt(url.substr(0, 1));\n        switch (version) {\n            case 1:\n                return this.decodeV1(url);\n            default:\n                break;\n        }\n        throw new Error(`Unsupported version ${version}`);\n    }\n\n    private decodeV1(url: string): DecodedItinerary {\n        let [data, dataVersion] = url.substr(1).split(\"!\");\n        if (dataVersion !== this.dataVersion) {\n            throw new DataVersionMismatchError(this.dataVersion, dataVersion);\n        }\n        let binary = Base64.toUint8Array(data);\n        let view = new DataView(binary.buffer);\n        let numLegs = view.getUint8(0);\n        let departureTime = new Date(view.getUint32(1, true) * 1000);\n        let legs: {\n            type: LegType;\n            departureStopId: number;\n            arrivalStopId: number;\n            routeId: number;\n            tripId: number;\n        }[] = [];\n        let offset = 5;\n        for (let i = 0; i < numLegs; i++) {\n            let type = view.getUint8(offset + 0);\n            let departureStopId = view.getUint16(offset + 1, true);\n            let arrivalStopId = view.getUint16(offset + 3, true);\n            offset += 5;\n            if (type === LegType.Transit) {\n                let routeId = view.getUint16(offset, true);\n                let tripId = view.getUint16(offset + 2, true);\n                offset += 4;\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId,\n                    tripId\n                });\n            } else {\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId: null,\n                    tripId: null\n                });\n            }\n        }\n        return {\n            departureTime,\n            version: 1,\n            legs\n        };\n    }\n\n\n}","import { Route } from \"./Route\";\nimport { Stop } from \"./Stop\";\n\nexport class RouteInfoStore {\n    constructor(private routeNames: [string, string, number, string | null][],\n        private stops: [string, number][]) {\n\n    }\n\n    getDiva(stopId: number) {\n        return this.stops[stopId][1];\n    }\n\n    getStop(stopId: number): Stop {\n        if (stopId > this.stops.length) {\n            throw new Error(`Invalid stop id ${stopId}`);\n        }\n        return {\n            stopId: stopId,\n            stopName: this.stops[stopId][0]\n        };\n    }\n\n    getRoute(routeId: number): Route {\n        if (routeId > this.routeNames.length) {\n            throw new Error(`Invalid route id ${routeId}`);\n        }\n        return {\n            name: this.routeNames[routeId][0],\n            id: routeId,\n            color: this.routeNames[routeId].length > 3 ? this.routeNames[routeId][3] : (this.routeNames[routeId][2] == 0 ? \"c4121a\" : \"\"),\n            headsign: this.routeNames[routeId][1]\n        };\n    }\n}\n","import { findTimeZone, getUnixTime, getZonedTime } from \"timezone-support/dist/lookup-convert\";\n\nfunction dayOfWeekToMask(dayOfWeek: number): number {\n    let mask = 0;\n    if (dayOfWeek == 0) {\n        mask = 64;\n    } else {\n        mask = 1 << (dayOfWeek - 1);\n    }\n    return mask;\n}\n\nexport function getStartOfDayVienna(date: Date) {\n    const vienna = findTimeZone(\"Europe/Vienna\");\n    const viennaTime = getZonedTime(date, vienna);\n    const startOfDayVienna = getUnixTime({\n        year: viennaTime.year,\n        month: viennaTime.month,\n        day: viennaTime.day,\n        hours: 0,\n        minutes: 0,\n        seconds: 0,\n    }, vienna);\n    return { unixTime: startOfDayVienna, dayOfWeek: dayOfWeekToMask(viennaTime.dayOfWeek) };\n}\n","import { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { MonitorResponse } from \"../ogd_realtime/MonitorResponse\";\nimport { Departure } from \"./Departure\";\nimport { getStartOfDayVienna } from \"./getStartOfDayVienna\";\nimport { Itinerary } from \"./Itinerary\";\nimport { Leg } from \"./Leg\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\n\nexport interface RouteRequest {\n    departureStops: number[];\n    arrivalStop: number;\n    departureTimes: Date[];\n}\n\nconst RAPTOR_MAX_REQUEST_STATIONS = 20;\n\nconst RAPTOR_LEG_SIZE = 24;\nconst RAPTOR_MAX_LEGS = 10;\nconst RAPTOR_ITINERARY_SIZE = RAPTOR_MAX_LEGS * RAPTOR_LEG_SIZE + 4;\nconst RAPTOR_MAX_ITINERARIES = 8;\nconst RAPTOR_RESULTS_SIZE = RAPTOR_MAX_ITINERARIES * RAPTOR_ITINERARY_SIZE + 4;\n\nconst RAPTOR_MAX_STOPTIME_UPDATES = 5;\nconst RAPTOR_UPDATE_RESULT_SIZE = 2 + 2 + 2 + 2;\n\nconst RAPTOR_STOPTIME_UPDATE_SIZE = 4 + // diva\n    2 +  // linie\n    1 + // direction\n    1 + // weekday\n    4 + // date\n    1 + // apply\n    1 + // num_updates\n    2 + // padding\n    RAPTOR_MAX_STOPTIME_UPDATES * 4 + // time_real\n    RAPTOR_MAX_STOPTIME_UPDATES * RAPTOR_UPDATE_RESULT_SIZE + // results\n    RAPTOR_MAX_STOPTIME_UPDATES * 1; // matches\n\nconst DEPARTURE_RESULT_SIZE = 2 + // route_id\n    2 + // stop_id\n    4 + // trip\n    4 + // planned_departure\n    2 + // delay\n    2; // padding\n\nconst MAX_DEPARTURE_RESULTS = 20;\nconst DEPARTURE_RESULTS_SIZE = MAX_DEPARTURE_RESULTS * DEPARTURE_RESULT_SIZE + 4;\n\n\nexport class RoutingService {\n    private mappedRealtimeData: { [routeId: number]: Set<number> } = {};\n    constructor(private routingInstance: WebAssemblyInstance<RaptorExports>,\n        private routeInfoStore: RouteInfoStore) {\n\n    }\n\n    getDepartures(r: { departureStops: { stopId: number, departureTime: Date }[] }): Departure[] {\n        this.setRequest(r);\n        let offset = this.routingInstance.exports.get_departures();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, offset, DEPARTURE_RESULTS_SIZE);\n        let numResults = view.getUint32(0, true);\n        let departures: Departure[] = [];\n        for (let i = 0; i < numResults; i++) {\n            let route = this.routeInfoStore.getRoute(view.getUint16(4 + i * DEPARTURE_RESULT_SIZE, true));\n            let tripId = view.getUint32(8 + i * DEPARTURE_RESULT_SIZE, true);\n            let departure: Departure = {\n                route: route,\n                stop: this.routeInfoStore.getStop(view.getUint16(6 + i * DEPARTURE_RESULT_SIZE, true)),\n                tripId: tripId,\n                plannedDeparture: new Date(view.getUint32(12 + i * DEPARTURE_RESULT_SIZE, true) * 1000),\n                delay: view.getInt16(16 + i * DEPARTURE_RESULT_SIZE, true),\n                isRealtime: this.mappedRealtimeData[route.id]?.has(tripId) || false\n            };\n            departures.push(departure);\n        }\n        return departures;\n    }\n\n    private setRequest(r: { departureStops: { stopId: number, departureTime: Date }[], arrivalStop?: number }) {\n        let requestMemory = this.routingInstance.exports.get_request_memory();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, requestMemory, 4 + 4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4);\n        view.setUint8(0, 0);\n        view.setUint8(1, Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length));\n        view.setUint8(2, 1);\n        let startOfDayVienna = getStartOfDayVienna(r.departureStops[0].departureTime);\n        view.setUint8(3, startOfDayVienna.dayOfWeek);\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            view.setUint16(4 + i * 2, r.departureStops[i].stopId, true);\n        }\n        if (typeof r.arrivalStop == \"number\") {\n            view.setUint16(4 + RAPTOR_MAX_REQUEST_STATIONS * 2, r.arrivalStop, true);\n        }\n        let departureDate = startOfDayVienna.unixTime / 1000;\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            let departureTime = (+r.departureStops[i].departureTime - startOfDayVienna.unixTime) / 1000;\n            view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + i * 4, departureTime, true);\n        }\n        view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4, departureDate, true);\n    }\n\n    route(request: RouteRequest) {\n        if (request.departureStops.length != request.departureTimes.length) {\n            throw new Error(\"departureStops and departureTimes must have the same length\");\n        }\n        performance.mark(\"routing-start\");\n        this.setRequest({ departureStops: request.departureStops.map((d, i) => ({ stopId: d, departureTime: request.departureTimes[i] })), arrivalStop: request.arrivalStop });\n        let resOffset = this.routingInstance.exports.raptor();\n        performance.mark(\"routing-done\");\n        performance.measure(\"routing\", \"routing-start\", \"routing-done\");\n        console.log(`routing took ${(performance.getEntriesByName(\"routing\")[0]).duration}ms`);\n        performance.clearMarks();\n        performance.clearMeasures();\n        return this.readResults(this.routingInstance.exports.memory, resOffset);\n    }\n\n    async updateRealtimeForStops(divas: number[]) {\n        let params = new URLSearchParams();\n        for (let diva of divas) {\n            params.append(\"diva\", diva.toString());\n        }\n        let res = await fetch(`https://realtime-api.grapp.workers.dev/ogd_realtime/monitor?${params}`);\n        let monitorResponse: MonitorResponse = await res.json();\n        for (let monitor of monitorResponse.data.monitors) {\n            for (let line of monitor.lines) {\n                let direction: number;\n                if (line.richtungsId == \"1\") {\n                    direction = 0;\n                } else if (line.richtungsId == \"2\") {\n                    direction = 1;\n                } else {\n                    throw new Error(`unknown richtungsId in monitor ${line.richtungsId}`);\n                }\n                let timeReal = line.departures.departure\n                    .filter(d => null != d.departureTime.timeReal)\n                    .map(d => new Date(d.departureTime.timeReal));\n                if (timeReal.length > 0) {\n                    this.upsertRealtimeData({\n                        diva: parseInt(monitor.locationStop.properties.name),\n                        linie: line.lineId,\n                        apply: true,\n                        direction: direction,\n                        timeReal: timeReal\n                    });\n                }\n            }\n        }\n\n    }\n\n    private readLeg(buffer: ArrayBuffer, offset: number): Leg {\n        let view = new DataView(buffer, offset, RAPTOR_LEG_SIZE);\n        let departureStopId = view.getUint16(4, true);\n        let arrivalStopId = view.getUint16(6, true);\n        let departureSeconds = view.getUint32(8, true);\n        let arrivalSeconds = view.getUint32(12, true);\n        let leg: Leg = {\n            type: view.getUint32(0, true),\n            departureStop: this.routeInfoStore.getStop(departureStopId),\n            arrivalStop: this.routeInfoStore.getStop(arrivalStopId),\n            plannedDeparture: new Date(departureSeconds * 1000),\n            delay: view.getInt16(18, true),\n            arrivalTime: new Date(arrivalSeconds * 1000),\n            duration: (arrivalSeconds - departureSeconds) * 1000,\n            route: null,\n            tripId: null,\n            isRealtime: false\n        };\n        if (leg.type == 1) {\n            let routeId = view.getUint16(16, true);\n            leg.route = this.routeInfoStore.getRoute(routeId);\n            leg.tripId = view.getUint32(20, true);\n            leg.isRealtime = this.mappedRealtimeData[leg.route.id]?.has(leg.tripId) || false;\n        }\n        return leg;\n    }\n\n    private readItinerary(buffer: ArrayBuffer, offset: number): Itinerary {\n        let legs = [];\n        let view = new DataView(buffer, offset, RAPTOR_ITINERARY_SIZE);\n        let numLegs = view.getUint32(0, true);\n        for (let i = 0; i < numLegs; i++) {\n            legs.push(this.readLeg(buffer, offset + 4 + i * RAPTOR_LEG_SIZE));\n        }\n        return { legs: legs.reverse() };\n    }\n\n    private readResults(memory: WebAssembly.Memory, offset: number): Itinerary[] {\n        let itineraries = [];\n        let view = new DataView(memory.buffer, offset, RAPTOR_RESULTS_SIZE);\n        let numItineraries = view.getUint32(0, true);\n        for (let i = 0; i < numItineraries; i++) {\n            let itinerary = this.readItinerary(memory.buffer, offset + 4 + i * RAPTOR_ITINERARY_SIZE);\n            itineraries.push(itinerary);\n        }\n        return itineraries;\n    }\n\n\n    private readStoptimeUpdate(buffer: ArrayBuffer, offset: number) {\n        let view = new DataView(buffer, offset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let routeId = view.getUint16(0, true);\n        let trip = view.getUint16(2, true);\n        let realtimeOffset = view.getInt16(4, true);\n        return {\n            routeId: routeId,\n            route: this.routeInfoStore.getRoute(routeId).name,\n            trip: trip,\n            realtimeOffset: realtimeOffset\n        };\n    }\n\n    getRealtimeUpdateResult() {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let numUpdates = dataView.getUint8(13);\n        let updates = [];\n        for (let i = 0; i < numUpdates; i++) {\n            let update = this.readStoptimeUpdate(this.routingInstance.exports.memory.buffer, memoryOffset + 16 + (4 * RAPTOR_MAX_STOPTIME_UPDATES) + (i * RAPTOR_UPDATE_RESULT_SIZE));\n            updates.push({ ...update, numMatches: dataView.getUint8(16 + RAPTOR_MAX_STOPTIME_UPDATES * (RAPTOR_UPDATE_RESULT_SIZE + 4) + i) });\n        }\n        return updates;\n    }\n\n    upsertRealtimeData(updates: {\n        diva: number,\n        linie: number,\n        direction: number,\n        timeReal: Date[],\n        apply: boolean\n    }) {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        dataView.setUint32(0, updates.diva, true);\n        dataView.setUint16(4, updates.linie, true);\n        dataView.setUint8(6, updates.direction);\n        let date = getStartOfDayVienna(updates.timeReal[0]);\n        dataView.setUint8(7, date.dayOfWeek);\n        dataView.setUint32(8, date.unixTime / 1000, true);\n        dataView.setUint8(12, updates.apply ? 1 : 0);\n        let numUpdates = Math.min(updates.timeReal.length, RAPTOR_MAX_STOPTIME_UPDATES);\n        dataView.setUint8(13, numUpdates);\n        for (let i = 0; i < numUpdates; i++) {\n            dataView.setUint32(16 + i * 4, (+updates.timeReal[i] - date.unixTime) / 1000, true);\n        }\n        this.routingInstance.exports.process_realtime();\n        let res = this.getRealtimeUpdateResult();\n        for (let update of res) {\n            if (update.numMatches > 0) {\n                this.mappedRealtimeData[update.routeId] = this.mappedRealtimeData[update.routeId] || new Set();\n                this.mappedRealtimeData[update.routeId].add(update.trip);\n            }\n        }\n    }\n}","import { Itinerary } from \"./Itinerary\";\nimport { LegType } from \"./LegType\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RouteUrlEncoder } from \"./RouteUrlEncoder\";\n\nexport class RouteDetailsService {\n    constructor(private routeUrlEncoder: RouteUrlEncoder,\n        private routeInfoStore: RouteInfoStore) {\n\n    }\n    getRouteByUrl(itineraryUrl: string): Itinerary {\n        let decoded = this.routeUrlEncoder.decode(itineraryUrl);\n        return {\n            legs: decoded.legs.map(l => ({\n                type: l.type,\n                departureStop: this.routeInfoStore.getStop(l.departureStopId),\n                arrivalStop: this.routeInfoStore.getStop(l.arrivalStopId),\n                route: l.type == LegType.Transit ? this.routeInfoStore.getRoute(l.routeId) : null,\n                tripId: l.tripId,\n                plannedDeparture: new Date(),\n                arrivalTime: new Date(),\n                delay: 0,\n                duration: 0,\n                isRealtime: false\n            }))\n\n        }\n    }\n}","import { RoutingService } from \"./RoutingService\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\n\nexport class RealtimeLookupService {\n    private lookedUpDivas = new Map<number, Date>();\n\n    constructor(private routeInfoStore: RouteInfoStore,\n        private routingService: RoutingService) {\n    }\n\n    async performWithRealtimeLoopkup(perform: () => Promise<number[]>) {\n        for (let i = 0; i < 10; i++) {\n            let stopIds = await perform();\n            let divas = stopIds.reduce((divas, stopId) => [...divas, this.routeInfoStore.getDiva(stopId)], [])\n                .filter(d => null != d && (!this.lookedUpDivas.has(d) || (new Date().getTime() - this.lookedUpDivas.get(d).getTime()) > 1000 * 30));\n            if (divas.length == 0) {\n                break;\n            }\n            await this.routingService.updateRealtimeForStops(Array.from(new Set(divas).values()));\n            for (let diva of divas) {\n                this.lookedUpDivas.set(diva, new Date());\n            }\n        }\n    }\n}\n","\nexport class StopGroupStore {\n    constructor(private sstopGroupIndex: { name: string; stopIds: number[]; }[]) {\n    }\n\n    getStopGroup(stopGroupId: number): { name: string; stopIds: number[]; } {\n        if (stopGroupId > this.sstopGroupIndex.length) {\n            throw new Error(`Invalid stop group id ${stopGroupId}`);\n        }\n        return this.sstopGroupIndex[stopGroupId];\n    }\n\n    findByStopId(stopId: number): { id: number; name: string; } {\n        let found = this.sstopGroupIndex.find(s => s.stopIds.includes(stopId));\n        if (null == found) {\n            return null;\n        }\n        return { id: found.stopIds.indexOf(stopId), name: found.name };\n    }\n}\n","import { StopSearchExports } from \"../../stopsearch/wasm-exports\";\nimport { ActionType } from \"./actions/ActionType\";\nimport { ArrivalStopTermChanged } from \"./actions/ArrivalStopTermChanged\";\nimport { DepartureStopTermChanged } from \"./actions/DepartureStopTermChanged\";\nimport { InitializeRouting } from \"./actions/InitializeRouting\";\nimport { InitializeStopSearch } from \"./actions/InitializeStopSearch\";\nimport { State } from \"./State\";\nimport { StopsSelected } from \"./actions/StopsSelected\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { SetDepartureTime } from \"./actions/SetDepartureTime\";\nimport { RouteUrlEncoder } from \"../lib/RouteUrlEncoder\";\nimport { RoutingServicesFactory } from \"../lib/RoutingServicesFactory\";\nimport { RouteDetailsOpened } from \"./actions/RouteDetailsOpened\";\n\ntype Actions = InitializeStopSearch\n    | DepartureStopTermChanged\n    | ArrivalStopTermChanged\n    | InitializeRouting\n    | StopsSelected\n    | SetDepartureTime\n    | RouteDetailsOpened;\n\nlet stopSearchInstance: WebAssemblyInstance<StopSearchExports>;\nlet _departureTime: Date = null;\n\nconst dataVersion = new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString().split(\"/\").pop().replace(\".bmp\", \"\");\nconst routeUrlEncoder = new RouteUrlEncoder(dataVersion);\n\nconst routingServicesFactory = new RoutingServicesFactory();\n\nasync function initRouting() {\n    await routingServicesFactory.getRoutingService();\n}\n\nasync function initStopSearch() {\n    if (stopSearchInstance) {\n        return;\n    }\n    let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<StopSearchExports>>>WebAssembly.instantiateStreaming(\n        fetch(new URL(\"../../stopsearch/stopsearch.wasm\", import.meta.url).toString())\n    ), fetch(new URL(\"../../preprocessing-dist/stop_search.bin.bmp\", import.meta.url).toString())]);\n    await Promise.all([await routingServicesFactory.getStopGroupStore(), copyToWasmMemory(instantiatedSource.instance, binaryResponse, 4, (instance, sizes) => instance.exports.stopsearch_allocate(sizes[0] / 12, sizes[1], sizes[3] / 2))]);\n    instantiatedSource.instance.exports.stopsearch_reset();\n    stopSearchInstance = instantiatedSource.instance;\n}\n\nlet lastValue: string = \"\";\nlet state: State = {\n    arrivalStopResults: [],\n    departureStopResults: [],\n    results: [],\n    routeDetail: null,\n    departures: [],\n    selectedStopgroups: {\n        departure: null,\n        arrival: null\n    }\n};\n\nfunction updateState(updateFn: (oldState: State) => Partial<State>) {\n    let update = updateFn(state);\n    state = {\n        ...state,\n        ...update\n    };\n    self.postMessage([update, Object.keys(update)]);\n}\n\nasync function searchTermChanged(term: string, departure: boolean) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    if (null == stopSearchInstance) {\n        return;\n    }\n    let value = term.toLowerCase()\n        .replace(/ä/g, \"a\")\n        .replace(/ö/g, \"o\")\n        .replace(/ü/g, \"u\")\n        .replace(/ß/g, \"ss\")\n        .replace(/[^a-z0-9]/g, \" \")\n        .replace(/ +(?= )/g, '')\n        .trim()\n    if (value == lastValue) {\n        return;\n    }\n    let result;\n    if (value.length == lastValue.length + 1 && value.startsWith(lastValue)) {\n        result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(value.length - 1));\n    } else {\n        result = stopSearchInstance.exports.stopsearch_reset();\n        for (let i = 0; i < value.length; i++) {\n            result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(i));\n        }\n    }\n    lastValue = value;\n    let resultArrayView = new DataView(stopSearchInstance.exports.memory.buffer, result, 2 * 4);\n    let resultsCount = resultArrayView.getUint32(0, true);\n    let resultsOffset = resultArrayView.getUint32(4, true);\n    let resultsView = new DataView(stopSearchInstance.exports.memory.buffer, resultsOffset, resultsCount * 2);\n    let results: { id: number, name: string }[] = [];\n    for (let i = 0; i < resultsCount; i++) {\n        let stopGroupId = resultsView.getUint16(i * 2, true);\n        let stopGroup = stopGroupStore.getStopGroup(stopGroupId);\n        results.push({ id: stopGroupId, name: stopGroup.name });\n    }\n    updateState(s => ({\n        [departure ? \"departureStopResults\" : \"arrivalStopResults\"]: results\n    }));\n}\n\nasync function searchInputChanged() {\n\n    if (state.selectedStopgroups.arrival != null && state.selectedStopgroups.departure != null) {\n        await route();\n    } else if (state.selectedStopgroups.departure != null) {\n        updateState(s => ({\n            results: []\n        }));\n        let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n        let routingService = await routingServicesFactory.getRoutingService();\n        let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n\n        let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n\n        await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n            let results = routingService.getDepartures({\n                departureStops: departureStops.map(d => ({ departureTime: _departureTime, stopId: d })),\n            });\n            updateState(() => ({ departures: results }));\n            return results.map(r => r.stop.stopId);\n        });\n    }\n}\n\nasync function stopsSelected(d: number, a: number) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    updateState(s => ({\n        selectedStopgroups: {\n            departure: d == null ? null : { id: d, name: stopGroupStore.getStopGroup(d).name },\n            arrival: a == null ? null : { id: a, name: stopGroupStore.getStopGroup(a).name }\n        }\n    }));\n    _departureTime = new Date();\n    await searchInputChanged();\n}\n\nasync function departureTimeInc(inc: number) {\n    if (null == _departureTime) {\n        return;\n    }\n    _departureTime = new Date(_departureTime.getTime() + inc);\n    await searchInputChanged();\n}\n\nasync function route() {\n    let routingService = await routingServicesFactory.getRoutingService();\n    let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n\n    let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n    let arrivalStop = stopGroupStore.getStopGroup(state.selectedStopgroups.arrival.id).stopIds[0];\n\n    await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n        let results = routingService.route({\n            arrivalStop: arrivalStop,\n            departureStops: departureStops,\n            departureTimes: departureStops.map(() => _departureTime)\n        });\n        updateState(() => ({ results: results.map(i => ({ itineraryUrlEncoded: routeUrlEncoder.encode(i), itinerary: i })) }));\n        return results.reduce((stopIds, r) => [...stopIds, ...r.legs.map(l => l.departureStop.stopId)], []);\n    });\n}\n\nasync function routeDetailsOpened(itineraryIdUrlEncoded: string) {\n    let routeDetailsService = await routingServicesFactory.getRouteDetailsService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    let itinerary = routeDetailsService.getRouteByUrl(itineraryIdUrlEncoded);\n    updateState(() => ({\n        routeDetail: { itineraryUrlEncoded: itineraryIdUrlEncoded, itinerary: itinerary },\n        selectedStopgroups: {\n            departure: stopGroupStore.findByStopId(itinerary.legs[0].departureStop.stopId),\n            arrival: stopGroupStore.findByStopId(itinerary.legs[itinerary.legs.length - 1].arrivalStop.stopId)\n        }\n    }));\n}\n\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.InitializeStopSearch:\n            await initStopSearch();\n            break;\n        case ActionType.DepartureStopTermChanged: {\n            searchTermChanged(msg.term, true);\n            break;\n        }\n        case ActionType.ArrivalStopTermChanged: {\n            searchTermChanged(msg.term, false);\n            break;\n        }\n        case ActionType.InitializeRouting: {\n            await initRouting();\n            break;\n        }\n        case ActionType.StopsSelected: {\n            await stopsSelected(msg.departure, msg.arrival);\n            break;\n        }\n        case ActionType.SetDepartureTime: {\n            await departureTimeInc(msg.increment);\n            break;\n        }\n        case ActionType.RouteDetailsOpened: {\n            await routeDetailsOpened(msg.itineraryUrlEncoded);\n            break;\n        }\n    }\n}\nself.postMessage([state, Object.keys(state)]);\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});","import { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RoutingService } from \"./RoutingService\";\nimport { populateTimeZones } from \"timezone-support/dist/lookup-convert\";\nimport { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { RouteDetailsService } from \"./RouteDetailsService\";\nimport { RouteUrlEncoder } from \"./RouteUrlEncoder\";\nimport { RealtimeLookupService } from \"./RealtimeLookupService\";\nimport { StopGroupStore } from \"./StopGroupStore\";\n\nexport class RoutingServicesFactory {\n    private routingServicePromise: Promise<RoutingService>;\n    private routeInfoStorePromise: Promise<RouteInfoStore>;\n    private timezonesPromise: Promise<void>;\n    private routingInstancePromise: Promise<WebAssemblyInstance<RaptorExports>>;\n    private routeDetailsServicePromise: Promise<RouteDetailsService>;\n    private readonly dataVersion = new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString().split(\"/\").pop().replace(\".bmp\", \"\");\n    private realtimeLookupServicePromise: Promise<RealtimeLookupService>;\n    private stopGroupStorePromise: Promise<StopGroupStore>;\n\n    private populateTimeZones() {\n        if (this.timezonesPromise == null) {\n            this.timezonesPromise = import(\"timezone-support/dist/data-2012-2022\").then(d => populateTimeZones(d));\n        }\n        return this.timezonesPromise;\n    }\n\n    private async createRouteInfoStore() {\n        let routeNamesTask = fetch(new URL(\"../../preprocessing-dist/routes.json\", import.meta.url).toString()).then(res => (res.json()) as Promise<[string, string, number, string | null][]>);\n        let stopNamesTask = fetch(new URL(\"../../preprocessing-dist/stops.json\", import.meta.url).toString()).then(res => res.json() as Promise<[string, number][]>);\n        let [routeNames, stopNames] = await Promise.all([routeNamesTask, stopNamesTask]);\n        return new RouteInfoStore(routeNames, stopNames);\n    }\n\n    private async createRoutingInstance() {\n        let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<RaptorExports>>>WebAssembly.instantiateStreaming(\n            fetch(new URL(\"../../raptor/raptor.wasm\", import.meta.url).toString())\n        ), fetch(new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString())]);\n        await copyToWasmMemory(instantiatedSource.instance, binaryResponse, 11,\n            (instance, sizes) => instance.exports.raptor_allocate(sizes[0], sizes[1], sizes[2], sizes[3], sizes[4], sizes[5], sizes[6], sizes[7], sizes[8], sizes[9], sizes[10]));\n        instantiatedSource.instance.exports.initialize();\n        return instantiatedSource.instance;\n    }\n\n    private async getRoutingInstance() {\n        if (this.routingInstancePromise == null) {\n            this.routingInstancePromise = this.createRoutingInstance();\n        }\n        return this.routingInstancePromise;\n    }\n\n    async getRouteInfoStore() {\n        if (this.routeInfoStorePromise == null) {\n            this.routeInfoStorePromise = this.createRouteInfoStore();\n        }\n        return this.routeInfoStorePromise;\n    }\n\n    private async createRoutingService() {\n        let [routingInstance, routeInfoStore] = await Promise.all([this.getRoutingInstance(), this.getRouteInfoStore(), this.populateTimeZones()])\n        return new RoutingService(routingInstance, routeInfoStore);\n    }\n\n    async getRoutingService() {\n        if (this.routingServicePromise == null) {\n            this.routingServicePromise = this.createRoutingService();\n        }\n        return this.routingServicePromise;\n    }\n\n    private async createRouteDetailsService() {\n        let routeInfoStore = await this.getRouteInfoStore();\n        return new RouteDetailsService(new RouteUrlEncoder(this.dataVersion), routeInfoStore);\n    }\n\n    async getRouteDetailsService() {\n        if (this.routeDetailsServicePromise == null) {\n            this.routeDetailsServicePromise = this.createRouteDetailsService();\n        }\n        return this.routeDetailsServicePromise;\n    }\n\n    private async createRealtimeLookupService() {\n        let [routingService, routeInfoStore] = await Promise.all([this.getRoutingService(), this.getRouteInfoStore()])\n        return new RealtimeLookupService(routeInfoStore, routingService);\n    }\n\n    async getRealtimeLookupService() {\n        if (this.realtimeLookupServicePromise == null) {\n            this.realtimeLookupServicePromise = this.createRealtimeLookupService();\n        }\n        return this.realtimeLookupServicePromise;\n    }\n\n    private async createStopGroupStore() {\n        let stopGroupIndexTask = fetch(new URL(\"../../preprocessing-dist/stopgroup-index.json\", import.meta.url).toString()).then(res => res.json()) as Promise<{ name: string; stopIds: number[] }[]>;\n        return new StopGroupStore(await stopGroupIndexTask);\n    }\n\n    async getStopGroupStore() {\n        if (this.stopGroupStorePromise == null) {\n            this.stopGroupStorePromise = this.createStopGroupStore();\n        }\n        return this.stopGroupStorePromise;\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [818,541], function() { return __webpack_require__(2887); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + {\"541\":\"7ab3da9dc2c605eaeffb\",\"818\":\"9060e930295b90c6f220\",\"955\":\"aca8258eee8d7b804046\"}[chunkId] + \".bundle.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t887: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpockmas\"] = self[\"webpackChunkpockmas\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","async","copyToWasmMemory","instance","res","numSizes","getOffset","offset","reader","body","getReader","done","sizes","sizesBuffer","Uint8Array","received","read","data","value","length","set","slice","Math","min","byteLength","view","DataView","buffer","i","push","getUint32","undefined","exports","memory","DataVersionMismatchError","Error","constructor","expected","actual","super","RouteUrlEncoder","dataVersion","UrlVersion","encode","r","binary","legs","filter","v","type","setUint8","setUint32","plannedDeparture","getTime","l","setUint16","departureStop","stopId","arrivalStop","route","_a","id","tripId","Base64","this","decode","url","version","parseInt","substr","decodeV1","split","numLegs","getUint8","departureTime","Date","departureStopId","getUint16","arrivalStopId","routeId","RouteInfoStore","routeNames","stops","getDiva","getStop","stopName","getRoute","name","color","headsign","dayOfWeekToMask","dayOfWeek","mask","getStartOfDayVienna","date","vienna","findTimeZone","viennaTime","getZonedTime","unixTime","getUnixTime","year","month","day","hours","minutes","seconds","RoutingService","routingInstance","routeInfoStore","mappedRealtimeData","getDepartures","setRequest","get_departures","MAX_DEPARTURE_RESULTS","numResults","departures","departure","stop","delay","getInt16","isRealtime","has","requestMemory","get_request_memory","departureStops","startOfDayVienna","departureDate","request","departureTimes","performance","mark","map","d","resOffset","raptor","measure","console","log","getEntriesByName","duration","clearMarks","clearMeasures","readResults","divas","params","URLSearchParams","diva","append","toString","fetch","monitorResponse","json","monitor","monitors","line","lines","direction","richtungsId","timeReal","upsertRealtimeData","locationStop","properties","linie","lineId","apply","readLeg","departureSeconds","arrivalSeconds","leg","arrivalTime","readItinerary","RAPTOR_MAX_LEGS","reverse","itineraries","numItineraries","RAPTOR_MAX_ITINERARIES","itinerary","readStoptimeUpdate","trip","realtimeOffset","getRealtimeUpdateResult","memoryOffset","get_stoptime_update_memory","dataView","numUpdates","updates","update","Object","numMatches","process_realtime","Set","add","RouteDetailsService","routeUrlEncoder","getRouteByUrl","itineraryUrl","RealtimeLookupService","routingService","lookedUpDivas","Map","perform","reduce","get","updateRealtimeForStops","Array","from","values","StopGroupStore","sstopGroupIndex","getStopGroup","stopGroupId","findByStopId","found","find","s","stopIds","includes","indexOf","stopSearchInstance","_departureTime","URL","pop","replace","routingServicesFactory","populateTimeZones","timezonesPromise","then","routeNamesTask","stopNamesTask","stopNames","Promise","all","instantiatedSource","binaryResponse","WebAssembly","instantiateStreaming","raptor_allocate","initialize","routingInstancePromise","createRoutingInstance","routeInfoStorePromise","createRouteInfoStore","getRoutingInstance","getRouteInfoStore","routingServicePromise","createRoutingService","routeDetailsServicePromise","createRouteDetailsService","getRoutingService","realtimeLookupServicePromise","createRealtimeLookupService","stopGroupIndexTask","stopGroupStorePromise","createStopGroupStore","lastValue","state","arrivalStopResults","departureStopResults","results","routeDetail","selectedStopgroups","arrival","updateState","updateFn","self","postMessage","keys","searchTermChanged","term","stopGroupStore","getStopGroupStore","result","toLowerCase","trim","startsWith","stopsearch_step","charCodeAt","stopsearch_reset","resultArrayView","resultsCount","resultsOffset","resultsView","stopGroup","searchInputChanged","realtimeLookupService","getRealtimeLookupService","performWithRealtimeLoopkup","itineraryUrlEncoded","addEventListener","ev","msg","stopsearch_allocate","initStopSearch","initRouting","a","stopsSelected","inc","departureTimeInc","increment","itineraryIdUrlEncoded","routeDetailsService","getRouteDetailsService","routeDetailsOpened","handleMessage","catch","err","error","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","getPrototypeOf","obj","__proto__","t","mode","__esModule","ns","create","def","current","getOwnPropertyNames","forEach","definition","o","defineProperty","enumerable","f","e","chunkId","promises","u","miniCssF","g","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","p","b","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime"],"sourceRoot":""}