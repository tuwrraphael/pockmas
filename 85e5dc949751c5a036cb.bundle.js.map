{"version":3,"file":"85e5dc949751c5a036cb.bundle.js","mappings":"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","sources":["webpack://pockmas/webpack/runtime/chunk loaded","webpack://pockmas/webpack/runtime/create fake namespace object","webpack://pockmas/webpack/runtime/startup chunk dependencies","webpack://pockmas/./src/utils/copyToWasmMemory.ts","webpack://pockmas/./src/lib/RouteUrlEncoder.ts","webpack://pockmas/./src/lib/RouteInfoStore.ts","webpack://pockmas/./src/lib/getStartOfDayVienna.ts","webpack://pockmas/./src/lib/RoutingService.ts","webpack://pockmas/./src/lib/RouteDetailsService.ts","webpack://pockmas/./src/lib/RealtimeLookupService.ts","webpack://pockmas/./src/lib/StopGroupStore.ts","webpack://pockmas/./src/state/worker.ts","webpack://pockmas/./src/lib/RoutingServicesFactory.ts","webpack://pockmas/webpack/bootstrap","webpack://pockmas/webpack/runtime/define property getters","webpack://pockmas/webpack/runtime/ensure chunk","webpack://pockmas/webpack/runtime/get javascript chunk filename","webpack://pockmas/webpack/runtime/get mini-css chunk filename","webpack://pockmas/webpack/runtime/global","webpack://pockmas/webpack/runtime/hasOwnProperty shorthand","webpack://pockmas/webpack/runtime/make namespace object","webpack://pockmas/webpack/runtime/publicPath","webpack://pockmas/webpack/runtime/importScripts chunk loading","webpack://pockmas/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });\n\t}\n\tdef['default'] = function() { return value; };\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(829),\n\t\t__webpack_require__.e(473)\n\t]).then(next);\n};","export async function copyToWasmMemory<T extends WebAssembly.Exports & { memory: WebAssembly.Memory; }>(instance: WebAssemblyInstance<T>,\n    res: Response,\n    numSizes: number,\n    getOffset: (instance: WebAssemblyInstance<T>, sizes: number[]) => number) {\n    let reader = res.body.getReader();\n    let done = false;\n    let offset;\n    let sizes = [];\n    let sizesBuffer = new Uint8Array(numSizes * 4);\n    let received = 0;\n    while (!done) {\n        let read = await reader.read();\n        done = read.done;\n        if (read.done) {\n            break;\n        }\n        let data = read.value;\n\n        if (sizes.length == 0) {\n            sizesBuffer.set(data.slice(0, Math.min(4 * numSizes - received, data.byteLength)), received);\n            received += data.byteLength;\n            if (received < numSizes * 4) {\n                continue;\n            } else {\n                let view = new DataView(sizesBuffer.buffer);\n                for (let i = 0; i < numSizes; i++) {\n                    sizes.push(view.getUint32(i * 4, true));\n                }\n                data = data.slice(numSizes * 4 - received);\n            }\n        }\n        if (sizes.length > 0 && offset == undefined) {\n            offset = getOffset(instance, sizes);\n        }\n        if (offset != undefined) {\n            new Uint8Array(instance.exports.memory.buffer, offset, data.length).set(data);\n            offset += data.length;\n        }\n    }\n}\n","import { LegType } from \"./LegType\";\nimport { Base64 } from \"js-base64\";\nimport { Stop } from \"./Stop\";\n\nconst UrlVersion = 1;\n\ninterface DecodedItinerary {\n    departureTime: Date;\n    version: number;\n    legs: {\n        type: LegType;\n        departureStopId: number;\n        arrivalStopId: number;\n        routeId: number;\n        tripId: number;\n    }[];\n\n}\n\nclass DataVersionMismatchError extends Error {\n    constructor(public expected: string, public actual: string) {\n        super(`Data version mismatch - expected ${expected}, actual ${actual}`);\n    }\n}\n\nexport class RouteUrlEncoder {\n    public readonly UrlVersion = UrlVersion;\n\n    constructor(private dataVersion: string) {\n\n    }\n\n    encode(r: {\n        legs: {\n            type: LegType;\n            departureStop: Stop;\n            arrivalStop: Stop;\n            route: {\n                id: number;\n            };\n            tripId: number | null;\n            plannedDeparture: Date;\n        }[]\n    }): string {\n        let binary = new Uint8Array(1 + 4 + r.legs.filter(v => v.type == LegType.Transit).length * 9 +\n            r.legs.filter(v => v.type == LegType.Walking).length * 5);\n        let view = new DataView(binary.buffer);\n        view.setUint8(0, r.legs.length);\n        view.setUint32(1, r.legs.length > 0 ? (r.legs[0].plannedDeparture.getTime() / 1000) : 0, true);\n        let offset = 5;\n        for (let l of r.legs) {\n            view.setUint8(offset + 0, l.type);\n            view.setUint16(offset + 1, l.departureStop.stopId, true);\n            view.setUint16(offset + 3, l.arrivalStop.stopId, true);\n            offset += 5;\n            if (l.type === LegType.Transit) {\n                view.setUint16(offset, l.route?.id || 0, true);\n                view.setUint16(offset + 2, l.tripId || 0, true);\n                offset += 4;\n            }\n        }\n        return `${UrlVersion}${Base64.fromUint8Array(binary, true)}!${this.dataVersion}`;\n    }\n\n    decode(url: string): DecodedItinerary {\n        let version = parseInt(url.substr(0, 1));\n        switch (version) {\n            case 1:\n                return this.decodeV1(url);\n            default:\n                break;\n        }\n        throw new Error(`Unsupported version ${version}`);\n    }\n\n    private decodeV1(url: string): DecodedItinerary {\n        let [data, dataVersion] = url.substr(1).split(\"!\");\n        if (dataVersion !== this.dataVersion) {\n            throw new DataVersionMismatchError(this.dataVersion, dataVersion);\n        }\n        let binary = Base64.toUint8Array(data);\n        let view = new DataView(binary.buffer);\n        let numLegs = view.getUint8(0);\n        let departureTime = new Date(view.getUint32(1, true) * 1000);\n        let legs: {\n            type: LegType;\n            departureStopId: number;\n            arrivalStopId: number;\n            routeId: number;\n            tripId: number;\n        }[] = [];\n        let offset = 5;\n        for (let i = 0; i < numLegs; i++) {\n            let type = view.getUint8(offset + 0);\n            let departureStopId = view.getUint16(offset + 1, true);\n            let arrivalStopId = view.getUint16(offset + 3, true);\n            offset += 5;\n            if (type === LegType.Transit) {\n                let routeId = view.getUint16(offset, true);\n                let tripId = view.getUint16(offset + 2, true);\n                offset += 4;\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId,\n                    tripId\n                });\n            } else {\n                legs.push({\n                    type,\n                    departureStopId,\n                    arrivalStopId,\n                    routeId: null,\n                    tripId: null\n                });\n            }\n        }\n        return {\n            departureTime,\n            version: 1,\n            legs\n        };\n    }\n\n\n}","import { RealtimeIdentifier } from \"./RealtimeIdentifier\";\nimport { Route } from \"./Route\";\nimport { RouteClass } from \"./RouteClass\";\nimport { Stop } from \"./Stop\";\n\nexport class RouteInfoStore {\n    constructor(private routes: [routeClass: number, headsignVariant: number][],\n        private routeClasses: {\n            routeClassName: string;\n            headsignVariants: string[],\n            routeType: number;\n            routeColor?: string;\n        }[],\n        private routeClassesByRealtimeIdentifier: [realtimeIdentiferType: number, realtimeIdentifier: number, ...routeClasses: number[]][],\n        private stops: [name: string, realtimeIdentifierType?: number, realtimeIdentifier?: number][]) {\n\n    }\n\n    getRealtimeIdentifier(stopId: number): RealtimeIdentifier {\n        if (this.stops[stopId].length < 1) {\n            return null;\n        }\n        return {\n            type: this.stops[stopId][1],\n            value: this.stops[stopId][2]\n        };\n    }\n\n    getStop(stopId: number): Stop {\n        if (stopId > this.stops.length) {\n            throw new Error(`Invalid stop id ${stopId}`);\n        }\n        return {\n            stopId: stopId,\n            stopName: this.stops[stopId][0]\n        };\n    }\n\n    getRoute(routeId: number): Route {\n        if (routeId > this.routes.length) {\n            throw new Error(`Invalid route id ${routeId}`);\n        }\n        let route = this.routes[routeId];\n        let routeClass = this.routeClasses[route[0]];\n        let color = \"\";\n        if (routeClass.routeColor) {\n            color = routeClass.routeColor;\n        } else if (routeClass.routeType == 0) {\n            color = \"c4121a\";\n        }\n        return {\n            name: this.routeClasses[route[0]].routeClassName,\n            id: routeId,\n            color: color,\n            headsign: routeClass.headsignVariants[route[1]]\n        };\n    }\n\n    getRouteClassesFotRealtimeIdentifier(realtimeIdentifier: RealtimeIdentifier): RouteClass[] {\n        let realtimeIdentifierType = realtimeIdentifier.type;\n        let realtimeIdentifierValue = realtimeIdentifier.value;\n        let routeClasses = this.routeClassesByRealtimeIdentifier.find(r => r[0] == realtimeIdentifierType && r[1] == realtimeIdentifierValue).slice(2);\n        return routeClasses.map(id => ({\n            routeClassName: this.routeClasses[id].routeClassName,\n            headsignVariants: this.routeClasses[id].headsignVariants,\n            id: id\n        }));\n    }\n}\n","import { findTimeZone, getUnixTime, getZonedTime } from \"timezone-support/dist/lookup-convert\";\n\nfunction dayOfWeekToMask(dayOfWeek: number): number {\n    let mask = 0;\n    if (dayOfWeek == 0) {\n        mask = 64;\n    } else {\n        mask = 1 << (dayOfWeek - 1);\n    }\n    return mask;\n}\n\nexport function getStartOfDayVienna(date: Date) {\n    const vienna = findTimeZone(\"Europe/Vienna\");\n    const viennaTime = getZonedTime(date, vienna);\n    const startOfDayVienna = getUnixTime({\n        year: viennaTime.year,\n        month: viennaTime.month,\n        day: viennaTime.day,\n        hours: 0,\n        minutes: 0,\n        seconds: 0,\n    }, vienna);\n    return { unixTime: startOfDayVienna, dayOfWeek: dayOfWeekToMask(viennaTime.dayOfWeek) };\n}\n","import { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { WienerLinienMonitorResponse } from \"../ogd_realtime/WienerLinienMonitorResponse\";\nimport { Departure } from \"./Departure\";\nimport { getStartOfDayVienna } from \"./getStartOfDayVienna\";\nimport { Itinerary } from \"./Itinerary\";\nimport { Leg } from \"./Leg\";\nimport { RealtimeData } from \"./RealtimeData\";\nimport { RealtimeIdentifier } from \"./RealtimeIdentifier\";\nimport { RealtimeIdentifierType } from \"./RealtimeIdentifierType\";\nimport { ResolvedRealtimeData } from \"./ResolvedRealtimeData\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { findBestMatch } from \"string-similarity\";\n\nexport interface RouteRequest {\n    departureStops: number[];\n    arrivalStop: number;\n    departureTimes: Date[];\n}\n\nconst RAPTOR_MAX_REQUEST_STATIONS = 20;\n\nconst RAPTOR_LEG_SIZE = 24;\nconst RAPTOR_MAX_LEGS = 10;\nconst RAPTOR_ITINERARY_SIZE = RAPTOR_MAX_LEGS * RAPTOR_LEG_SIZE + 4;\nconst RAPTOR_MAX_ITINERARIES = 8;\nconst RAPTOR_RESULTS_SIZE = RAPTOR_MAX_ITINERARIES * RAPTOR_ITINERARY_SIZE + 4;\n\nconst RAPTOR_MAX_STOPTIME_UPDATES = 5;\nconst RAPTOR_UPDATE_RESULT_SIZE = 2 + 2 + 2 + 2;\n\nconst RAPTOR_STOPTIME_UPDATE_SIZE = 4 + // realtime_route_identifier\n    2 +  // linie\n    1 + // direction\n    1 + // weekday\n    4 + // date\n    1 + // apply\n    1 + // num_updates\n    2 + // realtime_route_identifier_type\n    RAPTOR_MAX_STOPTIME_UPDATES * 4 + // time_real\n    RAPTOR_MAX_STOPTIME_UPDATES * RAPTOR_UPDATE_RESULT_SIZE + // results\n    RAPTOR_MAX_STOPTIME_UPDATES * 1; // matches\n\nconst DEPARTURE_RESULT_SIZE = 2 + // route_id\n    2 + // stop_id\n    4 + // trip\n    4 + // planned_departure\n    2 + // delay\n    2; // padding\n\nconst MAX_DEPARTURE_RESULTS = 10;\nconst DEPARTURE_RESULTS_SIZE = MAX_DEPARTURE_RESULTS * DEPARTURE_RESULT_SIZE + 4;\n\nexport class RoutingService {\n    private mappedRealtimeData: { [routeId: number]: Set<number> } = {};\n    constructor(private routingInstance: WebAssemblyInstance<RaptorExports>,\n        private routeInfoStore: RouteInfoStore) {\n\n    }\n\n    getDepartures(r: { departureStops: { stopId: number, departureTime: Date }[] }): Departure[] {\n        this.setRequest(r);\n        let offset = this.routingInstance.exports.get_departures();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, offset, DEPARTURE_RESULTS_SIZE);\n        let numResults = view.getUint32(0, true);\n        let departures: Departure[] = [];\n        for (let i = 0; i < numResults; i++) {\n            let route = this.routeInfoStore.getRoute(view.getUint16(4 + i * DEPARTURE_RESULT_SIZE, true));\n            let tripId = view.getUint32(8 + i * DEPARTURE_RESULT_SIZE, true);\n            let departure: Departure = {\n                route: route,\n                stop: this.routeInfoStore.getStop(view.getUint16(6 + i * DEPARTURE_RESULT_SIZE, true)),\n                tripId: tripId,\n                plannedDeparture: new Date(view.getUint32(12 + i * DEPARTURE_RESULT_SIZE, true) * 1000),\n                delay: view.getInt16(16 + i * DEPARTURE_RESULT_SIZE, true),\n                isRealtime: this.mappedRealtimeData[route.id]?.has(tripId) || false\n            };\n            departures.push(departure);\n        }\n        return departures;\n    }\n\n    private setRequest(r: { departureStops: { stopId: number, departureTime: Date }[], arrivalStop?: number }) {\n        let requestMemory = this.routingInstance.exports.get_request_memory();\n        let view = new DataView(this.routingInstance.exports.memory.buffer, requestMemory, 4 + 4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4);\n        view.setUint8(0, 0);\n        view.setUint8(1, Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length));\n        view.setUint8(2, 1);\n        let startOfDayVienna = getStartOfDayVienna(r.departureStops[0].departureTime);\n        view.setUint8(3, startOfDayVienna.dayOfWeek);\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            view.setUint16(4 + i * 2, r.departureStops[i].stopId, true);\n        }\n        if (typeof r.arrivalStop == \"number\") {\n            view.setUint16(4 + RAPTOR_MAX_REQUEST_STATIONS * 2, r.arrivalStop, true);\n        }\n        let departureDate = startOfDayVienna.unixTime / 1000;\n        for (let i = 0; i < Math.min(RAPTOR_MAX_REQUEST_STATIONS, r.departureStops.length); i++) {\n            let departureTime = (+r.departureStops[i].departureTime - startOfDayVienna.unixTime) / 1000;\n            view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + i * 4, departureTime, true);\n        }\n        view.setUint32(4 + (RAPTOR_MAX_REQUEST_STATIONS + RAPTOR_MAX_REQUEST_STATIONS) * 2 + RAPTOR_MAX_REQUEST_STATIONS * 4, departureDate, true);\n    }\n\n    route(request: RouteRequest) {\n        if (request.departureStops.length != request.departureTimes.length) {\n            throw new Error(\"departureStops and departureTimes must have the same length\");\n        }\n        performance.mark(\"routing-start\");\n        this.setRequest({ departureStops: request.departureStops.map((d, i) => ({ stopId: d, departureTime: request.departureTimes[i] })), arrivalStop: request.arrivalStop });\n        let resOffset = this.routingInstance.exports.raptor();\n        performance.mark(\"routing-done\");\n        performance.measure(\"routing\", \"routing-start\", \"routing-done\");\n        console.log(`routing took ${(performance.getEntriesByName(\"routing\")[0]).duration}ms`);\n        performance.clearMarks();\n        performance.clearMeasures();\n        return this.readResults(this.routingInstance.exports.memory, resOffset);\n    }\n\n    private async getRealtimeForWienerLinien(divas: number[]): Promise<RealtimeData[]> {\n        let params = new URLSearchParams();\n        for (let diva of divas) {\n            params.append(\"diva\", diva.toString());\n        }\n        let res = await fetch(`https://realtime-api.grapp.workers.dev/ogd_realtime/monitor?${params}`);\n        let monitorResponse: WienerLinienMonitorResponse = await res.json();\n        let result: RealtimeData[] = [];\n        for (let monitor of monitorResponse.data.monitors) {\n            let identifier: RealtimeIdentifier = {\n                type: RealtimeIdentifierType.WienerLinien,\n                value: parseInt(monitor.locationStop.properties.name)\n            };\n            for (let line of monitor.lines) {\n                let byLineAndHeadsign: Map<string, Map<string, Date[]>> = new Map();\n                for (let departure of line.departures.departure) {\n                    if (departure.departureTime?.timeReal || departure.departureTime?.timePlanned) {\n                        let byHeadsign: Map<string, Date[]> = byLineAndHeadsign.get(departure.vehicle?.name || line.name) || new Map();\n                        let departureTime = departure.departureTime.timeReal ? new Date(departure.departureTime.timeReal) : new Date(departure.departureTime.timePlanned);\n                        let departureTimes = byHeadsign.get(departure.vehicle?.towards || line.towards) || [];\n                        departureTimes.push(departureTime);\n                        byHeadsign.set(departure.vehicle?.towards || line.towards, departureTimes);\n                        byLineAndHeadsign.set(departure.vehicle?.name || line.name, byHeadsign);\n                    } else {\n                        console.log(`no departure time in departure`, departure);\n                    }\n                }\n                for (let [routeClassName, byHeadsign] of byLineAndHeadsign) {\n                    for (let [headsign, departureTimes] of byHeadsign) {\n                        let realtimeData: RealtimeData = {\n                            realtimeIdentifier: identifier,\n                            routeClassName: routeClassName,\n                            headsign: headsign,\n                            times: departureTimes\n                        };\n\n                        result.push(realtimeData);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    async updateRealtimeForStops(realtimeIdentifiers: RealtimeIdentifier[]) {\n        let data = await this.getRealtimeForWienerLinien(realtimeIdentifiers.filter(v => v.type == RealtimeIdentifierType.WienerLinien).map(i => i.value));\n        for (let realtimeData of data) {\n            this.upsertRealtimeData(realtimeData, true);\n        }\n    }\n\n    private readLeg(buffer: ArrayBuffer, offset: number): Leg {\n        let view = new DataView(buffer, offset, RAPTOR_LEG_SIZE);\n        let departureStopId = view.getUint16(4, true);\n        let arrivalStopId = view.getUint16(6, true);\n        let departureSeconds = view.getUint32(8, true);\n        let arrivalSeconds = view.getUint32(12, true);\n        let leg: Leg = {\n            type: view.getUint32(0, true),\n            departureStop: this.routeInfoStore.getStop(departureStopId),\n            arrivalStop: this.routeInfoStore.getStop(arrivalStopId),\n            plannedDeparture: new Date(departureSeconds * 1000),\n            delay: view.getInt16(18, true),\n            arrivalTime: new Date(arrivalSeconds * 1000),\n            duration: (arrivalSeconds - departureSeconds) * 1000,\n            route: null,\n            tripId: null,\n            isRealtime: false\n        };\n        if (leg.type == 1) {\n            let routeId = view.getUint16(16, true);\n            leg.route = this.routeInfoStore.getRoute(routeId);\n            leg.tripId = view.getUint32(20, true);\n            leg.isRealtime = this.mappedRealtimeData[leg.route.id]?.has(leg.tripId) || false;\n        }\n        return leg;\n    }\n\n    private readItinerary(buffer: ArrayBuffer, offset: number): Itinerary {\n        let legs = [];\n        let view = new DataView(buffer, offset, RAPTOR_ITINERARY_SIZE);\n        let numLegs = view.getUint32(0, true);\n        for (let i = 0; i < numLegs; i++) {\n            legs.push(this.readLeg(buffer, offset + 4 + i * RAPTOR_LEG_SIZE));\n        }\n        return { legs: legs.reverse() };\n    }\n\n    private readResults(memory: WebAssembly.Memory, offset: number): Itinerary[] {\n        let itineraries = [];\n        let view = new DataView(memory.buffer, offset, RAPTOR_RESULTS_SIZE);\n        let numItineraries = view.getUint32(0, true);\n        for (let i = 0; i < numItineraries; i++) {\n            let itinerary = this.readItinerary(memory.buffer, offset + 4 + i * RAPTOR_ITINERARY_SIZE);\n            itineraries.push(itinerary);\n        }\n        return itineraries;\n    }\n\n\n    private readStoptimeUpdate(buffer: ArrayBuffer, offset: number) {\n        let view = new DataView(buffer, offset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let routeId = view.getUint16(0, true);\n        let trip = view.getUint16(2, true);\n        let realtimeOffset = view.getInt16(4, true);\n        return {\n            routeId: routeId,\n            route: this.routeInfoStore.getRoute(routeId).name,\n            trip: trip,\n            realtimeOffset: realtimeOffset\n        };\n    }\n\n    getRealtimeUpdateResult() {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        let numUpdates = dataView.getUint8(13);\n        let updates = [];\n        for (let i = 0; i < numUpdates; i++) {\n            let update = this.readStoptimeUpdate(this.routingInstance.exports.memory.buffer, memoryOffset + 16 + (4 * RAPTOR_MAX_STOPTIME_UPDATES) + (i * RAPTOR_UPDATE_RESULT_SIZE));\n            updates.push({ ...update, numMatches: dataView.getUint8(16 + RAPTOR_MAX_STOPTIME_UPDATES * (RAPTOR_UPDATE_RESULT_SIZE + 4) + i) });\n        }\n        return updates;\n    }\n\n    upsertRealtimeData(realtimeData: RealtimeData, apply: boolean) {\n        performance.mark(\"realtime-upsert-start\");\n        let routeClasses = this.routeInfoStore.getRouteClassesFotRealtimeIdentifier(realtimeData.realtimeIdentifier);\n        let bestRouteClassMatch = findBestMatch(realtimeData.routeClassName.trim().toLowerCase(), routeClasses.map(rc => rc.routeClassName.toLowerCase()));\n        let bestRouteClass = routeClasses[bestRouteClassMatch.bestMatchIndex];\n        let match = realtimeData.headsign.replace(/^Wien /, \"\").trim().toLowerCase();\n        let variants = bestRouteClass.headsignVariants.map(h => h.replace(/^Wien /, \"\").toLowerCase());\n        let bestHeadsignVariantMatch = findBestMatch(match, variants);\n        this.upsertResolvedRealtimeData({\n            headsignVariant: bestHeadsignVariantMatch.bestMatchIndex,\n            realtimeIdentifier: realtimeData.realtimeIdentifier,\n            routeClass: bestRouteClass.id,\n            times: realtimeData.times\n        }, apply);\n        performance.mark(\"realtime-upsert-end\");\n        performance.measure(\"realtime-upsert\", \"realtime-upsert-start\", \"realtime-upsert-end\");\n        console.log(`Realtime upsert took ${performance.getEntriesByName(\"realtime-upsert\", \"measure\")[0].duration}ms`);\n        performance.clearMarks();\n        performance.clearMeasures();\n    }\n\n    private upsertResolvedRealtimeData(update: ResolvedRealtimeData, apply: boolean) {\n        let memoryOffset = this.routingInstance.exports.get_stoptime_update_memory();\n        let dataView = new DataView(this.routingInstance.exports.memory.buffer, memoryOffset, RAPTOR_STOPTIME_UPDATE_SIZE);\n        dataView.setUint32(0, update.realtimeIdentifier.value, true);\n        dataView.setUint16(4, update.routeClass, true);\n        dataView.setUint8(6, update.headsignVariant);\n        let date = getStartOfDayVienna(update.times[0]);\n        dataView.setUint8(7, date.dayOfWeek);\n        dataView.setUint32(8, date.unixTime / 1000, true);\n        dataView.setUint8(12, apply ? 1 : 0);\n        let numUpdates = Math.min(update.times.length, RAPTOR_MAX_STOPTIME_UPDATES);\n        dataView.setUint8(13, numUpdates);\n        for (let i = 0; i < numUpdates; i++) {\n            dataView.setUint32(16 + i * 4, (+update.times[i] - date.unixTime) / 1000, true);\n        }\n        this.routingInstance.exports.process_realtime();\n        let res = this.getRealtimeUpdateResult();\n        for (let update of res) {\n            if (update.numMatches > 0) {\n                this.mappedRealtimeData[update.routeId] = this.mappedRealtimeData[update.routeId] || new Set();\n                this.mappedRealtimeData[update.routeId].add(update.trip);\n            }\n        }\n    }\n}","import { Itinerary } from \"./Itinerary\";\nimport { LegType } from \"./LegType\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RouteUrlEncoder } from \"./RouteUrlEncoder\";\n\nexport class RouteDetailsService {\n    constructor(private routeUrlEncoder: RouteUrlEncoder,\n        private routeInfoStore: RouteInfoStore) {\n\n    }\n    getRouteByUrl(itineraryUrl: string): Itinerary {\n        let decoded = this.routeUrlEncoder.decode(itineraryUrl);\n        return {\n            legs: decoded.legs.map(l => ({\n                type: l.type,\n                departureStop: this.routeInfoStore.getStop(l.departureStopId),\n                arrivalStop: this.routeInfoStore.getStop(l.arrivalStopId),\n                route: l.type == LegType.Transit ? this.routeInfoStore.getRoute(l.routeId) : null,\n                tripId: l.tripId,\n                plannedDeparture: new Date(),\n                arrivalTime: new Date(),\n                delay: 0,\n                duration: 0,\n                isRealtime: false\n            }))\n\n        }\n    }\n}","import { RoutingService } from \"./RoutingService\";\nimport { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RealtimeIdentifier } from \"./RealtimeIdentifier\";\n\nexport class RealtimeLookupService {\n    private lookedUp: { rtIdentifier: RealtimeIdentifier, when: Date }[] = [];\n\n    constructor(private routeInfoStore: RouteInfoStore,\n        private routingService: RoutingService) {\n    }\n\n    private hasJustBeenLookedUp(rtIdentifier: RealtimeIdentifier) {\n        return this.lookedUp.some(lookedUp =>\n            lookedUp.rtIdentifier.type == rtIdentifier.type &&\n            lookedUp.rtIdentifier.value == rtIdentifier.value &&\n            (new Date().getTime() - lookedUp.when.getTime()) < 1000 * 30);\n    }\n\n    private setLookedUp(rtIdentifier: RealtimeIdentifier) {\n        let existing = this.lookedUp.find(lookedUp => lookedUp.rtIdentifier.type == rtIdentifier.type && lookedUp.rtIdentifier.value == rtIdentifier.value);\n        if (existing) {\n            existing.when = new Date();\n        }\n        else {\n            this.lookedUp.push({ rtIdentifier: rtIdentifier, when: new Date() });\n        }\n    }\n\n    async performWithRealtimeLoopkup(perform: () => Promise<number[]>) {\n        for (let i = 0; i < 10; i++) {\n            let stopIds = await perform();\n\n            let lookupIdentifiers: RealtimeIdentifier[] = [];\n            for (let id of stopIds.reduce((realtimeIdentifiers, stopId) => [...realtimeIdentifiers, this.routeInfoStore.getRealtimeIdentifier(stopId)], [])) {\n                if (id !== null && !this.hasJustBeenLookedUp(id) && !lookupIdentifiers.some(identifier => identifier.type == id.type && identifier.value == id.value)) {\n                    lookupIdentifiers.push(id);\n                }\n            }\n            if (lookupIdentifiers.length == 0) {\n                break;\n            }\n            await this.routingService.updateRealtimeForStops(lookupIdentifiers);\n            for (let id of lookupIdentifiers) {\n                this.setLookedUp(id);\n            }\n        }\n    }\n}\n","\nexport class StopGroupStore {\n    constructor(private sstopGroupIndex: { name: string; stopIds: number[]; }[]) {\n    }\n\n    getStopGroup(stopGroupId: number): { name: string; stopIds: number[]; } {\n        if (stopGroupId > this.sstopGroupIndex.length) {\n            throw new Error(`Invalid stop group id ${stopGroupId}`);\n        }\n        return this.sstopGroupIndex[stopGroupId];\n    }\n\n    findByStopId(stopId: number): { id: number; name: string; } {\n        let found = this.sstopGroupIndex.find(s => s.stopIds.includes(stopId));\n        if (null == found) {\n            return null;\n        }\n        return { id: found.stopIds.indexOf(stopId), name: found.name };\n    }\n}\n","import { StopSearchExports } from \"../../stopsearch/wasm-exports\";\nimport { ActionType } from \"./actions/ActionType\";\nimport { ArrivalStopTermChanged } from \"./actions/ArrivalStopTermChanged\";\nimport { DepartureStopTermChanged } from \"./actions/DepartureStopTermChanged\";\nimport { InitializeRouting } from \"./actions/InitializeRouting\";\nimport { InitializeStopSearch } from \"./actions/InitializeStopSearch\";\nimport { State } from \"./State\";\nimport { StopsSelected } from \"./actions/StopsSelected\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { SetDepartureTime } from \"./actions/SetDepartureTime\";\nimport { RouteUrlEncoder } from \"../lib/RouteUrlEncoder\";\nimport { RoutingServicesFactory } from \"../lib/RoutingServicesFactory\";\nimport { RouteDetailsOpened } from \"./actions/RouteDetailsOpened\";\nimport { DisplayMoreDepartures } from \"./actions/DisplayMoreDepartures\";\n\ntype Actions = InitializeStopSearch\n    | DepartureStopTermChanged\n    | ArrivalStopTermChanged\n    | InitializeRouting\n    | StopsSelected\n    | SetDepartureTime\n    | RouteDetailsOpened\n    | DisplayMoreDepartures;\n\nlet stopSearchInstance: WebAssemblyInstance<StopSearchExports>;\nlet _departureTime: Date = null;\n\nconst dataVersion = new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString().split(\"/\").pop().replace(\".bmp\", \"\");\nconst routeUrlEncoder = new RouteUrlEncoder(dataVersion);\n\nconst routingServicesFactory = new RoutingServicesFactory();\n\nasync function initRouting() {\n    await routingServicesFactory.getRoutingService();\n}\n\nasync function initStopSearch() {\n    if (stopSearchInstance) {\n        return;\n    }\n    let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<StopSearchExports>>>WebAssembly.instantiateStreaming(\n        fetch(new URL(\"../../stopsearch/stopsearch.wasm\", import.meta.url).toString())\n    ), fetch(new URL(\"../../preprocessing-dist/stop_search.bin.bmp\", import.meta.url).toString())]);\n    await Promise.all([await routingServicesFactory.getStopGroupStore(), copyToWasmMemory(instantiatedSource.instance, binaryResponse, 4, (instance, sizes) => instance.exports.stopsearch_allocate(sizes[0] / 12, sizes[1], sizes[3] / 2))]);\n    instantiatedSource.instance.exports.stopsearch_reset();\n    stopSearchInstance = instantiatedSource.instance;\n}\n\nlet lastValue: string = \"\";\nlet state: State = {\n    arrivalStopResults: [],\n    departureStopResults: [],\n    results: [],\n    routeDetail: null,\n    departures: [],\n    selectedStopgroups: {\n        departure: null,\n        arrival: null\n    }\n};\n\nfunction updateState(updateFn: (oldState: State) => Partial<State>) {\n    let update = updateFn(state);\n    state = {\n        ...state,\n        ...update\n    };\n    self.postMessage([update, Object.keys(update)]);\n}\n\nasync function searchTermChanged(term: string, departure: boolean) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    if (null == stopSearchInstance) {\n        return;\n    }\n    let value = term.toLowerCase()\n        .replace(/ä/g, \"a\")\n        .replace(/ö/g, \"o\")\n        .replace(/ü/g, \"u\")\n        .replace(/ß/g, \"ss\")\n        .replace(/[^a-z0-9]/g, \" \")\n        .replace(/ +(?= )/g, '')\n        .trim()\n    if (value == lastValue) {\n        return;\n    }\n    let result;\n    if (value.length == lastValue.length + 1 && value.startsWith(lastValue)) {\n        result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(value.length - 1));\n    } else {\n        result = stopSearchInstance.exports.stopsearch_reset();\n        for (let i = 0; i < value.length; i++) {\n            result = stopSearchInstance.exports.stopsearch_step(value.charCodeAt(i));\n        }\n    }\n    lastValue = value;\n    let resultArrayView = new DataView(stopSearchInstance.exports.memory.buffer, result, 2 * 4);\n    let resultsCount = resultArrayView.getUint32(0, true);\n    let resultsOffset = resultArrayView.getUint32(4, true);\n    let resultsView = new DataView(stopSearchInstance.exports.memory.buffer, resultsOffset, resultsCount * 2);\n    let results: { id: number, name: string }[] = [];\n    for (let i = 0; i < resultsCount; i++) {\n        let stopGroupId = resultsView.getUint16(i * 2, true);\n        let stopGroup = stopGroupStore.getStopGroup(stopGroupId);\n        results.push({ id: stopGroupId, name: stopGroup.name });\n    }\n    updateState(s => ({\n        [departure ? \"departureStopResults\" : \"arrivalStopResults\"]: results\n    }));\n}\n\nlet getDeparturesRunning: Promise<void> = Promise.resolve();\n\nasync function searchInputChanged() {\n\n    if (state.selectedStopgroups.arrival != null && state.selectedStopgroups.departure != null) {\n        await route();\n    } else if (state.selectedStopgroups.departure != null) {\n        getDeparturesRunning = (async () => {\n            updateState(s => ({\n                results: []\n            }));\n            let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n            let routingService = await routingServicesFactory.getRoutingService();\n            let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n\n            let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n\n            await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n                let results = routingService.getDepartures({\n                    departureStops: departureStops.map(d => ({ departureTime: _departureTime, stopId: d })),\n                });\n                updateState(() => ({ departures: results }));\n                return results.map(r => r.stop.stopId);\n            });\n        })();\n        await getDeparturesRunning;\n    }\n}\n\nasync function displayMoreDepartures() {\n    await getDeparturesRunning;\n    if (state.selectedStopgroups.departure != null && state.departures?.length > 0) {\n        getDeparturesRunning = (async () => {\n            let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n            let routingService = await routingServicesFactory.getRoutingService();\n            let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n\n            let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n            let departuresBefore = state.departures;\n            await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n                let results = routingService.getDepartures({\n                    departureStops: departureStops.map(d => ({ departureTime: new Date(departuresBefore[departuresBefore.length - 1].plannedDeparture.getTime() + departuresBefore[departuresBefore.length - 1].delay), stopId: d })),\n                });\n                let firstDuplicate = departuresBefore.findIndex(dbefore => results.some(dNew => dbefore.route.id == dNew.route.id && dbefore.tripId == dNew.tripId && dbefore.stop.stopId == dNew.stop.stopId));\n                if (firstDuplicate != -1) {\n                    firstDuplicate = departuresBefore.length;\n                }\n                updateState(() => ({ departures: [...departuresBefore.slice(0, firstDuplicate), ...results] }));\n                return results.map(r => r.stop.stopId);\n            });\n        })();\n    }\n}\n\nasync function stopsSelected(d: number, a: number) {\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    updateState(s => ({\n        selectedStopgroups: {\n            departure: d == null ? null : { id: d, name: stopGroupStore.getStopGroup(d).name },\n            arrival: a == null ? null : { id: a, name: stopGroupStore.getStopGroup(a).name }\n        }\n    }));\n    _departureTime = new Date();\n    await searchInputChanged();\n}\n\nasync function departureTimeInc(inc: number) {\n    if (null == _departureTime) {\n        return;\n    }\n    _departureTime = new Date(_departureTime.getTime() + inc);\n    await searchInputChanged();\n}\n\nasync function route() {\n    let routingService = await routingServicesFactory.getRoutingService();\n    let realtimeLookupService = await routingServicesFactory.getRealtimeLookupService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n\n    let departureStops = stopGroupStore.getStopGroup(state.selectedStopgroups.departure.id).stopIds;\n    let arrivalStop = stopGroupStore.getStopGroup(state.selectedStopgroups.arrival.id).stopIds[0];\n\n    await realtimeLookupService.performWithRealtimeLoopkup(async () => {\n        let results = routingService.route({\n            arrivalStop: arrivalStop,\n            departureStops: departureStops,\n            departureTimes: departureStops.map(() => _departureTime)\n        });\n        updateState(() => ({ results: results.map(i => ({ itineraryUrlEncoded: routeUrlEncoder.encode(i), itinerary: i })) }));\n        return results.reduce((stopIds, r) => [...stopIds, ...r.legs.map(l => l.departureStop.stopId)], []);\n    });\n}\n\nasync function routeDetailsOpened(itineraryIdUrlEncoded: string) {\n    let routeDetailsService = await routingServicesFactory.getRouteDetailsService();\n    let stopGroupStore = await routingServicesFactory.getStopGroupStore();\n    let itinerary = routeDetailsService.getRouteByUrl(itineraryIdUrlEncoded);\n    updateState(() => ({\n        routeDetail: { itineraryUrlEncoded: itineraryIdUrlEncoded, itinerary: itinerary },\n        selectedStopgroups: {\n            departure: stopGroupStore.findByStopId(itinerary.legs[0].departureStop.stopId),\n            arrival: stopGroupStore.findByStopId(itinerary.legs[itinerary.legs.length - 1].arrivalStop.stopId)\n        }\n    }));\n}\n\nasync function handleMessage(msg: Actions) {\n    switch (msg.type) {\n        case ActionType.InitializeStopSearch:\n            await initStopSearch();\n            break;\n        case ActionType.DepartureStopTermChanged: {\n            searchTermChanged(msg.term, true);\n            break;\n        }\n        case ActionType.ArrivalStopTermChanged: {\n            searchTermChanged(msg.term, false);\n            break;\n        }\n        case ActionType.InitializeRouting: {\n            await initRouting();\n            break;\n        }\n        case ActionType.StopsSelected: {\n            await stopsSelected(msg.departure, msg.arrival);\n            break;\n        }\n        case ActionType.SetDepartureTime: {\n            await departureTimeInc(msg.increment);\n            break;\n        }\n        case ActionType.RouteDetailsOpened: {\n            await routeDetailsOpened(msg.itineraryUrlEncoded);\n            break;\n        }\n        case ActionType.DisplayMoreDepartures: {\n            await displayMoreDepartures();\n            break;\n        }\n    }\n}\nself.postMessage([state, Object.keys(state)]);\nself.addEventListener(\"message\", ev => {\n    let msg: Actions = ev.data;\n    handleMessage(msg).catch(err => console.error(err));\n});","import { RouteInfoStore } from \"./RouteInfoStore\";\nimport { RoutingService } from \"./RoutingService\";\nimport { populateTimeZones } from \"timezone-support/dist/lookup-convert\";\nimport { RaptorExports } from \"../../raptor/wasm-exports\";\nimport { copyToWasmMemory } from \"../utils/copyToWasmMemory\";\nimport { RouteDetailsService } from \"./RouteDetailsService\";\nimport { RouteUrlEncoder } from \"./RouteUrlEncoder\";\nimport { RealtimeLookupService } from \"./RealtimeLookupService\";\nimport { StopGroupStore } from \"./StopGroupStore\";\n\nexport class RoutingServicesFactory {\n    private routingServicePromise: Promise<RoutingService>;\n    private routeInfoStorePromise: Promise<RouteInfoStore>;\n    private timezonesPromise: Promise<void>;\n    private routingInstancePromise: Promise<WebAssemblyInstance<RaptorExports>>;\n    private routeDetailsServicePromise: Promise<RouteDetailsService>;\n    private readonly dataVersion = new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString().split(\"/\").pop().replace(\".bmp\", \"\");\n    private realtimeLookupServicePromise: Promise<RealtimeLookupService>;\n    private stopGroupStorePromise: Promise<StopGroupStore>;\n\n    private populateTimeZones() {\n        if (this.timezonesPromise == null) {\n            this.timezonesPromise = import(\"timezone-support/dist/data-2012-2022\").then(d => populateTimeZones(d));\n        }\n        return this.timezonesPromise;\n    }\n\n    private async createRouteInfoStore() {\n        let routesTask = fetch(new URL(\"../../preprocessing-dist/routes.json\", import.meta.url).toString()).then(res => (res.json()) as Promise<[number, number][]>);\n        let stopsTask = fetch(new URL(\"../../preprocessing-dist/stops.json\", import.meta.url).toString()).then(res => res.json() as Promise<[string, number, number][]>);\n        let routeClassesTask = fetch(new URL(\"../../preprocessing-dist/route-classes.json\", import.meta.url).toString()).then(res => res.json() as Promise<{\n            routeClassName: string;\n            headsignVariants: string[];\n            routeType: number;\n            routeColor?: string;\n        }[]>);\n        let routeClassesByRealtimeIdentifierTask = fetch(new URL(\"../../preprocessing-dist/route-classes-by-realtime-identifier.json\", import.meta.url).toString()).then(res => res.json() as Promise<[type: number, value: number, ...routeClasses: number[]][]>);\n        let [routes, stops, routeClasses, routeClassesByRealtimeIdentifier] = await Promise.all([routesTask, stopsTask, routeClassesTask, routeClassesByRealtimeIdentifierTask]);\n        return new RouteInfoStore(routes, routeClasses, routeClassesByRealtimeIdentifier, stops);\n    }\n\n    private async createRoutingInstance() {\n        let [instantiatedSource, binaryResponse] = await Promise.all([<Promise<WebAssemblyInstantiatedSource<RaptorExports>>>WebAssembly.instantiateStreaming(\n            fetch(new URL(\"../../raptor/raptor.wasm\", import.meta.url).toString())\n        ), fetch(new URL(\"../../preprocessing-dist/raptor_data.bin.bmp\", import.meta.url).toString())]);\n        await copyToWasmMemory(instantiatedSource.instance, binaryResponse, 11,\n            (instance, sizes) => instance.exports.raptor_allocate(sizes[0], sizes[1], sizes[2], sizes[3], sizes[4], sizes[5], sizes[6], sizes[7], sizes[8], sizes[9], sizes[10]));\n        instantiatedSource.instance.exports.initialize();\n        return instantiatedSource.instance;\n    }\n\n    private async getRoutingInstance() {\n        if (this.routingInstancePromise == null) {\n            this.routingInstancePromise = this.createRoutingInstance();\n        }\n        return this.routingInstancePromise;\n    }\n\n    async getRouteInfoStore() {\n        if (this.routeInfoStorePromise == null) {\n            this.routeInfoStorePromise = this.createRouteInfoStore();\n        }\n        return this.routeInfoStorePromise;\n    }\n\n    private async createRoutingService() {\n        let [routingInstance, routeInfoStore] = await Promise.all([this.getRoutingInstance(), this.getRouteInfoStore(), this.populateTimeZones()])\n        return new RoutingService(routingInstance, routeInfoStore);\n    }\n\n    async getRoutingService() {\n        if (this.routingServicePromise == null) {\n            this.routingServicePromise = this.createRoutingService();\n        }\n        return this.routingServicePromise;\n    }\n\n    private async createRouteDetailsService() {\n        let routeInfoStore = await this.getRouteInfoStore();\n        return new RouteDetailsService(new RouteUrlEncoder(this.dataVersion), routeInfoStore);\n    }\n\n    async getRouteDetailsService() {\n        if (this.routeDetailsServicePromise == null) {\n            this.routeDetailsServicePromise = this.createRouteDetailsService();\n        }\n        return this.routeDetailsServicePromise;\n    }\n\n    private async createRealtimeLookupService() {\n        let [routingService, routeInfoStore] = await Promise.all([this.getRoutingService(), this.getRouteInfoStore()])\n        return new RealtimeLookupService(routeInfoStore, routingService);\n    }\n\n    async getRealtimeLookupService() {\n        if (this.realtimeLookupServicePromise == null) {\n            this.realtimeLookupServicePromise = this.createRealtimeLookupService();\n        }\n        return this.realtimeLookupServicePromise;\n    }\n\n    private async createStopGroupStore() {\n        let stopGroupIndexTask = fetch(new URL(\"../../preprocessing-dist/stopgroup-index.json\", import.meta.url).toString()).then(res => res.json()) as Promise<{ name: string; stopIds: number[] }[]>;\n        return new StopGroupStore(await stopGroupIndexTask);\n    }\n\n    async getStopGroupStore() {\n        if (this.stopGroupStorePromise == null) {\n            this.stopGroupStorePromise = this.createStopGroupStore();\n        }\n        return this.stopGroupStorePromise;\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [829,473], function() { return __webpack_require__(2887); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + {\"473\":\"555b48af762420a1e009\",\"829\":\"3b66761374760b6d4099\",\"955\":\"aca8258eee8d7b804046\"}[chunkId] + \".bundle.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t887: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkpockmas\"] = self[\"webpackChunkpockmas\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","async","copyToWasmMemory","instance","res","numSizes","getOffset","offset","reader","body","getReader","done","sizes","sizesBuffer","Uint8Array","received","read","data","value","length","set","slice","Math","min","byteLength","view","DataView","buffer","i","push","getUint32","undefined","exports","memory","DataVersionMismatchError","Error","constructor","expected","actual","super","RouteUrlEncoder","dataVersion","UrlVersion","encode","r","binary","legs","filter","v","type","setUint8","setUint32","plannedDeparture","getTime","l","setUint16","departureStop","stopId","arrivalStop","route","_a","id","tripId","Base64","this","decode","url","version","parseInt","substr","decodeV1","split","numLegs","getUint8","departureTime","Date","departureStopId","getUint16","arrivalStopId","routeId","RouteInfoStore","routes","routeClasses","routeClassesByRealtimeIdentifier","stops","getRealtimeIdentifier","getStop","stopName","getRoute","routeClass","color","routeColor","routeType","name","routeClassName","headsign","headsignVariants","getRouteClassesFotRealtimeIdentifier","realtimeIdentifier","realtimeIdentifierType","realtimeIdentifierValue","find","map","dayOfWeekToMask","dayOfWeek","mask","getStartOfDayVienna","date","vienna","findTimeZone","viennaTime","getZonedTime","unixTime","getUnixTime","year","month","day","hours","minutes","seconds","RoutingService","routingInstance","routeInfoStore","mappedRealtimeData","getDepartures","setRequest","get_departures","MAX_DEPARTURE_RESULTS","numResults","departures","departure","stop","delay","getInt16","isRealtime","has","requestMemory","get_request_memory","departureStops","startOfDayVienna","departureDate","request","departureTimes","performance","mark","d","resOffset","raptor","measure","console","log","getEntriesByName","duration","clearMarks","clearMeasures","readResults","divas","params","URLSearchParams","diva","append","toString","fetch","monitorResponse","json","result","monitor","monitors","identifier","locationStop","properties","line","lines","byLineAndHeadsign","Map","timeReal","_b","timePlanned","byHeadsign","get","vehicle","_c","_d","towards","_e","_f","realtimeData","times","realtimeIdentifiers","getRealtimeForWienerLinien","upsertRealtimeData","readLeg","departureSeconds","arrivalSeconds","leg","arrivalTime","readItinerary","RAPTOR_MAX_LEGS","reverse","itineraries","numItineraries","RAPTOR_MAX_ITINERARIES","itinerary","readStoptimeUpdate","trip","realtimeOffset","getRealtimeUpdateResult","memoryOffset","get_stoptime_update_memory","dataView","numUpdates","updates","update","Object","numMatches","apply","bestRouteClassMatch","findBestMatch","trim","toLowerCase","rc","bestRouteClass","bestMatchIndex","match","replace","variants","h","bestHeadsignVariantMatch","upsertResolvedRealtimeData","headsignVariant","process_realtime","Set","add","RouteDetailsService","routeUrlEncoder","getRouteByUrl","itineraryUrl","RealtimeLookupService","routingService","lookedUp","hasJustBeenLookedUp","rtIdentifier","some","when","setLookedUp","existing","perform","stopIds","lookupIdentifiers","reduce","updateRealtimeForStops","StopGroupStore","sstopGroupIndex","getStopGroup","stopGroupId","findByStopId","found","s","includes","indexOf","stopSearchInstance","_departureTime","URL","pop","routingServicesFactory","populateTimeZones","timezonesPromise","then","routesTask","stopsTask","routeClassesTask","routeClassesByRealtimeIdentifierTask","Promise","all","instantiatedSource","binaryResponse","WebAssembly","instantiateStreaming","raptor_allocate","initialize","routingInstancePromise","createRoutingInstance","routeInfoStorePromise","createRouteInfoStore","getRoutingInstance","getRouteInfoStore","routingServicePromise","createRoutingService","routeDetailsServicePromise","createRouteDetailsService","getRoutingService","realtimeLookupServicePromise","createRealtimeLookupService","stopGroupIndexTask","stopGroupStorePromise","createStopGroupStore","lastValue","state","arrivalStopResults","departureStopResults","results","routeDetail","selectedStopgroups","arrival","updateState","updateFn","self","postMessage","keys","searchTermChanged","term","stopGroupStore","getStopGroupStore","startsWith","stopsearch_step","charCodeAt","stopsearch_reset","resultArrayView","resultsCount","resultsOffset","resultsView","stopGroup","getDeparturesRunning","resolve","searchInputChanged","realtimeLookupService","getRealtimeLookupService","performWithRealtimeLoopkup","itineraryUrlEncoded","addEventListener","ev","msg","stopsearch_allocate","initStopSearch","initRouting","a","stopsSelected","inc","departureTimeInc","increment","itineraryIdUrlEncoded","routeDetailsService","getRouteDetailsService","routeDetailsOpened","departuresBefore","firstDuplicate","findIndex","dbefore","dNew","displayMoreDepartures","handleMessage","catch","err","error","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","m","x","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","key","splice","getPrototypeOf","obj","__proto__","t","mode","__esModule","ns","create","def","current","getOwnPropertyNames","forEach","definition","o","defineProperty","enumerable","f","e","chunkId","promises","u","miniCssF","g","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","p","b","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime"],"sourceRoot":""}